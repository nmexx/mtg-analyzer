import React, { useState, useEffect, useRef } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

import { RAMP_SPELL_DATA }                                           from '../Card_Archive/Ramp_Spells.js';
import { ARTIFACT_DATA, SIMPLIFY_MOX_CONDITIONS, MOX_PRIORITY_ARTIFACTS, BURST_MANA_SOURCES } from '../Card_Archive/Artifacts.js';
import { FETCH_LAND_DATA }                                           from '../Card_Archive/Fetch_Lands.js';
import { EXPLORATION_EFFECTS }                                        from '../Card_Archive/Exploration_Effects.js';
import { MANA_DORK_DATA }                                             from '../Card_Archive/Mana_Dorks.js';
import { RITUAL_DATA }                                                from '../Card_Archive/Rituals.js';
import LANDS_JSON, { SPECIAL_LANDS }                                  from '../Card_Archive/Lands.js';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Keyed by lowercase land name â†’ { cycleName, behavior, sim_flags, color_identity }
//
// sim_flags mirrors the boolean properties used throughout processLand():
//   entersTappedAlways  â€“ land always ETBs tapped (no conditional untap)
//   isBounce            â€“ land bounces a land back to hand on ETB
//   isReveal            â€“ ETB-tapped unless a land type is revealed from hand
//   isCheck             â€“ ETB-tapped unless appropriate land type is controlled
//   isFast              â€“ ETB-tapped unless â‰¤2 other lands are controlled
//   isBattleLand        â€“ ETB-tapped unless 2+ basic lands are controlled
//   isPathway           â€“ MDFC pathway, always ETBs untapped
//   isCrowd             â€“ ETB-tapped unless 2+ opponents exist (commander)
//   isOdysseyFilter     â€“ Odyssey/Fallout filter lands (untapped, {1} for color)
//   isManLand           â€“ creature land (always ETBs tapped)
//   isHideawayFetch     â€“ SNC auto-sacrifice fetch (not really a Set, resolved via FETCH_LAND_DATA)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LAND_DATA = (() => {
  const map = new Map();
  for (const cycle of LANDS_JSON.cycles) {
    const cycleFlags = cycle.sim_flags || {};
    for (const land of cycle.lands) {
      const key = land.name.toLowerCase();
      if (!map.has(key)) {
        // Merge cycle-level sim_flags with any per-land sim_flags overrides
        const flags = land.sim_flags
          ? { ...cycleFlags, ...land.sim_flags }
          : cycleFlags;
        map.set(key, {
          cycleName:      cycle.name,
          behavior:       cycle.behavior || {},
          sim_flags:      flags,
          color_identity: land.color_identity || [],
          types:          land.types || land.reveals || [],
        });
      }
    }
  }
  return map;
})();

// html2canvas library will be loaded from CDN
const loadHtml2Canvas = () => {
  return new Promise((resolve, reject) => {
    if (window.html2canvas) {
      resolve(window.html2canvas);
      return;
    }

    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
    script.onload = () => resolve(window.html2canvas);
    script.onerror = reject;
    document.head.appendChild(script);
  });
};

const MTGMonteCarloAnalyzer = () => {
  // State Management
  const [apiMode, setApiMode] = useState('local'); // 'local' or 'scryfall'
  const [cardsDatabase, setCardsDatabase] = useState(null);
  const [cardLookupMap, setCardLookupMap] = useState(new Map());
  const [deckText, setDeckText] = useState('');
  const [parsedDeck, setParsedDeck] = useState(null);
  const [selectedKeyCards, setSelectedKeyCards] = useState(new Set());
  const [enableMulligans, setEnableMulligans] = useState(false);
  const [mulliganRule, setMulliganRule] = useState('london'); // 'london' or 'vancouver'
  const [mulliganStrategy, setMulliganStrategy] = useState('balanced'); // 'conservative', 'balanced', 'aggressive', 'custom'
  const [customMulliganRules, setCustomMulliganRules] = useState({
    mulligan0Lands: true,
    mulligan7Lands: true,
    mulliganNoPlaysByTurn: false,
    noPlaysTurnThreshold: 2,
    mulliganMinLands: false,
    minLandsThreshold: 1,
    mulliganMaxLands: false,
    maxLandsThreshold: 5
  });
  const [includeCreatures, setIncludeCreatures] = useState(true);
  const [includeArtifacts, setIncludeArtifacts] = useState(true);
  const [disabledCreatures, setDisabledCreatures] = useState(new Set());
  const [disabledArtifacts, setDisabledArtifacts] = useState(new Set());
  const [includeExploration, setIncludeExploration] = useState(true);
  const [disabledExploration, setDisabledExploration] = useState(new Set());
  const [includeRampSpells, setIncludeRampSpells] = useState(true);
  const [disabledRampSpells, setDisabledRampSpells] = useState(new Set());
  const [includeRituals, setIncludeRituals] = useState(true);
  const [disabledRituals, setDisabledRituals] = useState(new Set());


  const [simulationResults, setSimulationResults] = useState(null);
  const [isSimulating, setIsSimulating] = useState(false);
  const [error, setError] = useState('');

  // Settings
  const [iterations, setIterations] = useState(10000);
  const [turns, setTurns] = useState(7);
  const [handSize, setHandSize] = useState(7);
  const [maxSequences, setMaxSequences] = useState(1);
  const [selectedTurnForSequences, setSelectedTurnForSequences] = useState(3);
  const [commanderMode, setCommanderMode] = useState(false); // Commander format settings

  // File upload handler
  const handleFileUpload = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (file.size > 1024 * 1024 * 1024) {
      setError('File too large (max 1 GB). The Scryfall Default Cards file should be around 200-300 MB.');
      return;
    }

    try {
      const text = await file.text();
      const data = JSON.parse(text);

      if (!Array.isArray(data)) {
        setError('Invalid JSON format. Expected an array of card objects.');
        return;
      }

      setCardsDatabase(data);

      // Build lookup map - skip tokens
      const lookupMap = new Map();
      let skippedTokens = 0;

      data.forEach(card => {
        // Skip tokens - we only want real playable cards
        if (card.layout === 'token' ||
          card.layout === 'double_faced_token' ||
          card.set_type === 'token' ||
          card.type_line?.includes('Token')) {
          skippedTokens++;
          return;
        }

        const name = card.name.toLowerCase();

        // If a card with this name already exists, prefer the one with higher CMC
        // (real cards over tokens if somehow a token slipped through)
        if (lookupMap.has(name)) {
          const existing = lookupMap.get(name);
          if ((card.cmc || 0) > (existing.cmc || 0)) {
            lookupMap.set(name, card);
          }
        } else {
          lookupMap.set(name, card);
        }
      });

      setCardLookupMap(lookupMap);

      setError('');
      console.log(`âœ“ Loaded ${data.length} cards from uploaded file (${skippedTokens} tokens filtered out)`);
    } catch (err) {
      setError('Invalid JSON file. Please check the file format.');
      console.error(err);
    }
  };

  // Card lookup function
  const lookupCard = async (cardName) => {
    const searchName = cardName.toLowerCase().trim();

    // Check cache first
    if (cardLookupMap.has(searchName)) {
      return cardLookupMap.get(searchName);
    }

    // Fuzzy matching
    for (const [name, card] of cardLookupMap.entries()) {
      if (name.startsWith(searchName) || name.includes(searchName)) {
        return card;
      }
    }

    // Scryfall API fallback
    if (apiMode === 'scryfall') {
      try {
        const response = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cardName)}`);
        if (response.ok) {
          const data = await response.json();

          // DEBUG: Log what we got from Scryfall
          if (data.cmc === 0 && data.name) {
            console.log(`ðŸ” Scryfall returned for "${cardName}":`, {
              name: data.name,
              type_line: data.type_line,
              layout: data.layout,
              set_type: data.set_type,
              cmc: data.cmc,
              mana_cost: data.mana_cost
            });
          }

          // Skip tokens - we only want real playable cards
          if (data.layout === 'token' || data.layout === 'double_faced_token' ||
            data.set_type === 'token' || data.type_line?.includes('Token')) {
            console.warn(`âš ï¸ Skipping token for: ${cardName}`);

            // Try searching for the non-token version
            const searchResponse = await fetch(`https://api.scryfall.com/cards/search?q=!"${encodeURIComponent(cardName)}"+-is:token&unique=cards&order=released`);
            if (searchResponse.ok) {
              const searchData = await searchResponse.json();
              if (searchData.data && searchData.data.length > 0) {
                const nonToken = searchData.data[0]; // Get the first non-token result
                console.log(`âœ… Found non-token version:`, nonToken.name, 'CMC:', nonToken.cmc);
                cardLookupMap.set(searchName, nonToken);
                return nonToken;
              }
            }
            return null; // No non-token version found
          }

          cardLookupMap.set(searchName, data);
          return data;
        }
      } catch (err) {
        console.error('Scryfall API error:', err);
      }
    }

    return null;
  };

  // RAMP_SPELL_DATA imported from Card_Archive/Ramp_Spells.js

  // Returns true if a land card in the library matches a ramp spell's search restriction.
  const matchesRampFilter = (land, rampSpell) => {
    if (!land.isLand) return false;
    switch (rampSpell.fetchFilter) {
      case 'any':
        return true;
      case 'basic':
        return !!land.isBasic;
      case 'subtype':
        // Land must have at least one of the specified basic land subtypes.
        // This covers basics AND dual/shock/triome lands with matching subtypes.
        return !!(rampSpell.fetchSubtypes && land.landSubtypes &&
          rampSpell.fetchSubtypes.some(t => land.landSubtypes.includes(t)));
      case 'snow':
        // Treat any land whose name contains 'snow' or is a basic snow land.
        return !!(land.name && land.name.toLowerCase().includes('snow'));
      default:
        return !!land.isBasic;
    }
  };

  // ARTIFACT_DATA imported from Card_Archive/Artifacts.js

  // EXPLORATION_EFFECTS imported from Card_Archive/Mana_Dorks.js

  // SIMPLIFY_MOX_CONDITIONS, MOX_PRIORITY_ARTIFACTS, BURST_MANA_SOURCES
  // imported from Card_Archive/Artifacts.js

  // RITUAL_DATA imported from Card_Archive/Rituals.js
  // SPECIAL_LANDS imported from Card_Archive/Lands.js (derived from 'Special Lands' cycle)

  // FETCH_LAND_DATA imported from Card_Archive/Fetch_Lands.js

  // KNOWN_FETCH_LANDS is now derived directly from the data map so the two never drift.
  const KNOWN_FETCH_LANDS = new Set(FETCH_LAND_DATA.keys());

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Land cycle Sets â€“ now derived from LAND_DATA (built from Lands.json) so that
  // adding a new land to the JSON automatically propagates here.
  // Hard-coded fallback entries are kept for cycles not yet in the JSON.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Helper: collect all names from LAND_DATA with a given sim_flag set to true.
  const landNamesWithFlag = (flag) => {
    const names = [];
    for (const [name, entry] of LAND_DATA.entries()) {
      if (entry.sim_flags && entry.sim_flags[flag]) names.push(name);
    }
    return names;
  };

  // Comprehensive land cycle detection â€” all entries now derived from Lands.json via LAND_DATA.
  // landNamesWithFlag(flag) returns every land name whose resolved sim_flags include that flag.
  const LANDS_ENTER_TAPPED_ALWAYS = new Set(landNamesWithFlag('entersTappedAlways'));

  // Bounce Lands (return a land to hand on ETB)
  const BOUNCE_LANDS = new Set(landNamesWithFlag('isBounce'));

  // Reveal Lands (ETB tapped unless matching land type is revealed from hand)
  const REVEAL_LANDS = new Set(landNamesWithFlag('isReveal'));

  // Check Lands (ETB tapped unless matching land type is already controlled)
  const CHECK_LANDS = new Set(landNamesWithFlag('isCheck'));

  // Fast Lands (ETB untapped only if 2 or fewer other lands are controlled)
  const FAST_LANDS = new Set(landNamesWithFlag('isFast'));

  // Pain Lands (always ETB untapped; deal 1 damage when tapped for colored mana)
  const PAIN_LANDS = new Set(landNamesWithFlag('isPainLand'));

  // 5-Color Pain Lands (Mana Confluence, City of Brass â€” any color, 1 damage)
  const FIVE_COLOR_PAIN_LANDS = new Set(landNamesWithFlag('isFiveColorPainLand'));

  // Filter Lands (ETB untapped; {1},{T} to filter into 2 pips of chosen colors)
  const FILTER_LANDS = new Set(landNamesWithFlag('isFilterLand'));

  // Horizon Lands (ETB untapped; can sacrifice to draw a card)
  const HORIZON_LANDS = new Set(landNamesWithFlag('isHorizonLand'));

  // Man Lands (creature lands â€” always ETB tapped)
  const MAN_LANDS = new Set(landNamesWithFlag('isManLand'));

  // Storage Lands (ETB tapped; accumulate storage counters for mana)
  const STORAGE_LANDS = new Set(landNamesWithFlag('isStorageLand'));

  // Crowd / Bond Lands (ETB tapped unless 2+ opponents exist)
  const CROWD_LANDS = new Set(landNamesWithFlag('isCrowd'));

  // Utility Lands that always ETB untapped (Command Tower, Reliquary Tower, etc.)
  const UTILITY_LANDS_UNTAPPED = new Set(landNamesWithFlag('isUtilityUntapped'));

  // Odyssey / Fallout Filter Lands (ETB untapped; {1},{T} produces 2 pips of color)
  const ODYSSEY_FILTER_LANDS = new Set(landNamesWithFlag('isOdysseyFilter'));

  // Hideaway Lands â€” Lorwyn utility hideaways + SNC auto-sacrifice fetch lands
  const HIDEAWAY_LANDS = new Set([
    ...landNamesWithFlag('isHideawayFetch'),
    ...(() => {
      const names = [];
      for (const [name, entry] of LAND_DATA.entries()) {
        if (entry.cycleName === 'Hideaway Lands') names.push(name);
      }
      return names;
    })(),
  ]);

  // Conditional Life Lands (ETB tapped unless an opponent condition is met)
  const CONDITIONAL_LIFE_LANDS = new Set(landNamesWithFlag('isConditionalLife'));

  // Battle / Tango Lands (ETB tapped unless 2+ basic lands are controlled)
  const BATTLE_LANDS = new Set(landNamesWithFlag('isBattleLand'));

  // Pathway Lands (MDFC â€” both faces always ETB untapped)
  const PATHWAY_LANDS = new Set(landNamesWithFlag('isPathway'));

  // Card processing functions
  const processCardData = (data) => {
    let frontFace = data;
    let isMDFC = false;

    // Handle MDFC - but exclude transform cards
    // Transform cards (like Legion's Landing) are NOT modal double-faced cards
    // They are regular cards that transform, so the front face determines the type
    if (data.card_faces && data.card_faces.length > 0) {
      const layout = data.layout?.toLowerCase() || '';

      // Only treat as MDFC if it's actually a modal double-faced card
      // Layouts: 'modal_dfc', 'transform', 'double_faced_token', etc.
      if (layout === 'modal_dfc') {
        frontFace = data.card_faces[0];
        const backFace = data.card_faces[1];
        isMDFC = true;

        // Check both faces
        const frontIsLand = frontFace.type_line?.toLowerCase().includes('land');
        const backIsLand = backFace.type_line?.toLowerCase().includes('land');

        // If EITHER side is a land, it can be played as a land
        if (frontIsLand || backIsLand) {
          // For land side, use the land face
          const landFace = frontIsLand ? frontFace : backFace;
          return processLand(data, landFace, isMDFC);
        }

        // If front is not a land, process as spell (even if back is land)
        // This allows MDFCs like Kazuul's Fury to be selected as key cards
        // The land will be processed separately above
      }
      // For transform cards, treat as regular spell (front face only)
      else if (layout === 'transform' || layout === 'double_faced_token') {
        // Use front face type to determine card type
        frontFace = data.card_faces[0];
        isMDFC = false; // Not a modal DFC
      }
    }

    // Regular land check
    const isLand = !isMDFC && data.type_line?.toLowerCase().includes('land');
    if (isLand) {
      return processLand(data, data, false);
    }

    // Check for mana production ability
    const hasManaTap = hasManaTapAbility(data.oracle_text || frontFace.oracle_text);

    // Mana creature check (includes artifact creatures)
    const cardName = data.name.toLowerCase();
    const isCreature = (data.type_line || frontFace.type_line)?.includes('Creature');
    if (isCreature && hasManaTap) {
      return processManaCreature(data);
    }

    // Mana artifact check (only non-creature artifacts)
    const isArtifact = (data.type_line || frontFace.type_line)?.includes('Artifact');
    if (isArtifact && !isCreature && hasManaTap) {
      return processManaArtifact(data);
    }

    // Also catch mana artifacts that are known by name but whose oracle text does
    // NOT follow the standard "{T}: Add" pattern.
    // Exclude burst sources (LED, Jeweled Lotus, Lotus Petal) â€” they must stay in
    // hand as uncast spells so the burst-mana graph calculation can find them.
    if (isArtifact && !isCreature && ARTIFACT_DATA.has(cardName) && !BURST_MANA_SOURCES.has(cardName)) {
      return processManaArtifact(data);
    }

    // Check for exploration effects (allows playing multiple lands per turn)
    if (EXPLORATION_EFFECTS.has(cardName)) {
      return processExploration(data);
    }

    // Check for ramp spells (sorceries/instants that put lands onto the battlefield)
    if (RAMP_SPELL_DATA.has(cardName)) {
      return processRampSpell(data);
    }

    // Check for ritual spells (burst-mana sorceries/instants)
    if (RITUAL_DATA.has(cardName)) {
      return processRitual(data);
    }

    // Regular spell
    return processSpell(data);
  };

  const hasManaTapAbility = (oracleText) => {
    if (!oracleText) return false;
    return /\{t\}:?\s*add|add\s*\{[wubrgc]/i.test(oracleText);
  };

  const processLand = (data, face, isMDFC) => {
    const name = data.name.toLowerCase();
    const oracleText = face.oracle_text || '';

    // Look up this land in the data-driven LAND_DATA map (built from Lands.js).
    // Provides authoritative sim_flags, color_identity, types, and cycleName.
    const ldEntry = LAND_DATA.get(name);

    // CRITICAL: Exclude transform cards that have land on back side
    // These cannot be played as lands directly (e.g., Profane Procession, Legion's Landing)
    if (data.layout === 'transform' && data.card_faces && data.card_faces.length > 0) {
      const frontFace = data.card_faces[0];
      const backFace = data.card_faces[1];
      const frontIsLand = frontFace.type_line?.toLowerCase().includes('land');
      const backIsLand = backFace.type_line?.toLowerCase().includes('land');

      // If front is NOT a land but back is, this is a transform card
      // that transforms INTO a land - cannot be played as land
      if (!frontIsLand && backIsLand) {
        return null; // Return null to indicate this shouldn't be processed as a land
      }
    }

    // Detect fetch land
    // Check the data map first (authoritative), then fall back to oracle-text heuristics.
    const knownFetch = FETCH_LAND_DATA.get(name);
    const isFetch = !!knownFetch ||
      (oracleText.includes('search your library') &&
        oracleText.includes('land card') &&
        oracleText.includes('battlefield'));

    let fetchType = null;
    let fetchColors = [];
    let isHideawayFetch = false;
    let fetchesOnlyBasics = false;
    let fetchesTwoLands = false;
    let fetchcost = 0;
    let fetchedLandEntersTapped = false; // Does the fetched land enter tapped?
    let entersTappedAlways = false; // Does the land itself enter tapped?
    let isBounce = false;
    let isReveal = false;
    let isCheck = false;
    let isFast = false;
    let isBattleLand = false;
    let isPathway = false;

    if (isFetch) {
      if (knownFetch) {
        // â”€â”€ Data-map lookup (authoritative) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        fetchType             = knownFetch.fetchType;
        fetchColors           = knownFetch.fetchColors;
        fetchesOnlyBasics     = knownFetch.fetchesOnlyBasics;
        fetchesTwoLands       = knownFetch.fetchesTwoLands;
        fetchedLandEntersTapped = knownFetch.fetchedLandEntersTapped;
        isHideawayFetch       = knownFetch.isHideawayFetch ?? false;
        fetchcost             = knownFetch.fetchcost ?? 0;
        // entersTappedAlways is handled below in the tapped-detection block;
        // seed it from the map so it can be further overridden if needed.
        if (knownFetch.entersTappedAlways) entersTappedAlways = true;
      } else {
        // â”€â”€ Oracle-text fallback for unknown fetch lands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (HIDEAWAY_LANDS.has(name)) {
          // Legacy hideaway lands not yet in the data map
          fetchType = 'hideaway';
          isHideawayFetch = true;
          fetchesOnlyBasics = true;
          if (oracleText.includes('{T}: Add')) {
            const manaSymbols = oracleText.match(/\{[WUBRGC]\}/g);
            if (manaSymbols) {
              const colorToType = { 'W': 'Plains', 'U': 'Island', 'B': 'Swamp', 'R': 'Mountain', 'G': 'Forest' };
              const colors = [...new Set(manaSymbols.map(s => s.replace(/[{}]/g, '')))];
              fetchColors = colors.map(c => colorToType[c] || c).filter(Boolean);
            }
          }
        } else if (oracleText.toLowerCase().includes('basic land')) {
          fetchType = 'free_slow';
          fetchesOnlyBasics = true;
          fetchedLandEntersTapped = true;
          fetchColors = ['W', 'U', 'B', 'R', 'G'];
        } else if (oracleText.toLowerCase().includes('pay 1 life') && !oracleText.toLowerCase().includes('tapped')) {
          fetchType = 'classic';
        } else if (oracleText.toLowerCase().includes('pay 1 life') && oracleText.toLowerCase().includes('tapped')) {
          fetchType = 'slow';
        } else if (oracleText.match(/\{[0-9]+\}/)) {
          fetchType = 'mana_cost';
        } else {
          fetchType = 'free_slow';
        }

        // Extract fetch colors from oracle text for unknown non-basic fetches
        if (!isHideawayFetch && !fetchesOnlyBasics) {
          const typeMatch = oracleText.match(/(Plains|Island|Swamp|Mountain|Forest)/g);
          if (typeMatch) {
            const typeToColor = { 'Plains': 'W', 'Island': 'U', 'Swamp': 'B', 'Mountain': 'R', 'Forest': 'G' };
            fetchColors = [...new Set(typeMatch.map(t => typeToColor[t]))];
          }
        }
      }
    }

    // Extract land subtypes
    const landSubtypes = [];
    if (face.type_line) {
      const types = face.type_line.split('â€”')[1];
      if (types) {
        const basicTypes = ['Plains', 'Island', 'Swamp', 'Mountain', 'Forest', 'Wastes'];
        basicTypes.forEach(type => {
          if (types.includes(type)) landSubtypes.push(type);
        });
      }
    }
    // Supplement from LAND_DATA when type_line parsing misses subtypes (e.g. check/reveal
    // lands whose type_line has no basic land types but whose logical check types are known).
    if (landSubtypes.length === 0 && ldEntry?.types?.length) {
      landSubtypes.push(...ldEntry.types);
    }

    // Detect if this is a basic land
    // Basic lands have the "Basic" supertype in their type_line
    const isBasic = face.type_line?.includes('Basic') ||
      // Also check by name for common basics
      ['plains', 'island', 'swamp', 'mountain', 'forest', 'wastes'].includes(name);

    // Extract mana production
    const produces = [];

    // Special case: 5-color pain lands produce all 5 colors
    if (FIVE_COLOR_PAIN_LANDS.has(name)) {
      produces.push('W', 'U', 'B', 'R', 'G');
    }
    // Special case: Command Tower and Path of Ancestry produce all 5 colors
    else if (name === 'command tower' || name === 'path of ancestry') {
      produces.push('W', 'U', 'B', 'R', 'G');
    }
    else if (oracleText.includes('{T}: Add')) {
      const manaSymbols = oracleText.match(/\{[WUBRGC]\}/g);
      if (manaSymbols) {
        manaSymbols.forEach(symbol => {
          const color = symbol.replace(/[{}]/g, '');
          if (!produces.includes(color)) produces.push(color);
        });
      }

      if (oracleText.includes('any color') || oracleText.includes('mana of any color')) {
        produces.push('W', 'U', 'B', 'R', 'G');
      }
    }

    // When oracle text parsing found no produces (e.g. filter lands, storage lands, vivid lands,
    // pain lands) fall back to color_identity from LAND_DATA â€” it is always authoritative.
    if (produces.length === 0 && ldEntry?.color_identity?.length) {
      ldEntry.color_identity.forEach(c => { if (!produces.includes(c)) produces.push(c); });
    }

    // Special case: Ancient Tomb produces {C}{C}
    // City of Traitors produces {C}{C}
    const manaAmount = (name === 'ancient tomb' || name === 'city of traitors') ? 2 : 1;

    // Determine if enters tapped using comprehensive lists
    isBounce = false;
    isReveal = false;
    isCheck = false;
    isFast = false;
    isBattleLand = false;
    isPathway = false;

    // Check hardcoded lists first (most reliable)
    // Determine if this land has internal logic (vs. pure oracle text parsing)
    let hasInternalLogic = false;

    // Check if land is in any special set (has hardcoded logic)
    // Also flag any land present in LAND_DATA (from Lands.json) as having known logic.
    if (FIVE_COLOR_PAIN_LANDS.has(name) || HIDEAWAY_LANDS.has(name) || KNOWN_FETCH_LANDS.has(name) ||
      CONDITIONAL_LIFE_LANDS.has(name) || BOUNCE_LANDS.has(name) ||
      BATTLE_LANDS.has(name) || PATHWAY_LANDS.has(name) || CHECK_LANDS.has(name) ||
      FAST_LANDS.has(name) || CROWD_LANDS.has(name) || ODYSSEY_FILTER_LANDS.has(name) ||
      PAIN_LANDS.has(name) || LAND_DATA.has(name) ||
      name === 'starting town' || name === 'ancient tomb' ||
      name === 'city of traitors') {
      hasInternalLogic = true;
    }

    if (LANDS_ENTER_TAPPED_ALWAYS.has(name)) {
      entersTappedAlways = true;
    } else if (knownFetch?.entersTappedAlways) {
      // Fetch land ETB-tapped flag comes from FETCH_LAND_DATA (already seeded above, re-affirm here)
      entersTappedAlways = true;
    } else if (HIDEAWAY_LANDS.has(name)) {
      entersTappedAlways = true;
    } else if (CONDITIONAL_LIFE_LANDS.has(name)) {
      // These enter tapped unless opponent condition (conservative: always tapped)
      entersTappedAlways = true;
    } else if (BOUNCE_LANDS.has(name)) {
      entersTappedAlways = true;
      isBounce = true;
    } else if (BATTLE_LANDS.has(name)) {
      // Battle lands: enter tapped unless you control 2+ basic lands
      isBattleLand = true;
    } else if (PATHWAY_LANDS.has(name)) {
      // Pathway lands always enter untapped â€” both sides are lands that ETB untapped.
      // entersTappedAlways remains false.
      isPathway = true;
    } else if (REVEAL_LANDS.has(name)) {
      // Reveal lands: enter tapped unless you reveal appropriate land
      // For simulation: assume conservative (always tapped)
      entersTappedAlways = true;
      isReveal = true;
    } else if (CHECK_LANDS.has(name)) {
      // Check lands: enter tapped unless you control appropriate basic type
      // Will be checked dynamically in doesLandEnterTapped
      isCheck = true;
    } else if (FAST_LANDS.has(name)) {
      // Fast lands: enter untapped if 2 or fewer other lands
      // Will be checked dynamically in doesLandEnterTapped
      isFast = true;
    } else if (PAIN_LANDS.has(name)) {
      // Pain lands always enter untapped
      entersTappedAlways = false;
    } else if (FIVE_COLOR_PAIN_LANDS.has(name)) {
      // 5-color pain lands (Mana Confluence, City of Brass) always enter untapped
      entersTappedAlways = false;
    } else if (FILTER_LANDS.has(name)) {
      entersTappedAlways = false; // Filter lands enter UNTAPPED
    } else if (MAN_LANDS.has(name)) {
      entersTappedAlways = true;
    } else if (STORAGE_LANDS.has(name)) {
      entersTappedAlways = true;
    } else if (CROWD_LANDS.has(name)) {
      // Crowd lands: enter condition depends on Commander Mode
      // Logic moved to doesLandEnterTapped() which has access to commanderMode
      entersTappedAlways = undefined; // Will be determined at runtime
    } else if (UTILITY_LANDS_UNTAPPED.has(name)) {
      // Utility lands always enter untapped
      entersTappedAlways = false;
    } else if (ODYSSEY_FILTER_LANDS.has(name)) {
      // Odyssey/Fallout filter lands enter untapped
      // Note: They require {1} for colored mana, but we simplify to always produce colored
      entersTappedAlways = false;
    } else {
      // Fallback to oracle text parsing
      const hasEntersTappedText = oracleText.toLowerCase().includes('enters the battlefield tapped') ||
        oracleText.toLowerCase().includes('enters tapped');
      const hasUnlessCondition = oracleText.includes('unless') ||
        oracleText.includes('if you control') ||
        oracleText.includes('if an opponent') ||
        oracleText.includes('As ~ enters');

      entersTappedAlways = hasEntersTappedText && !hasUnlessCondition;
    }

    // Prefer the authoritative sim_flag over the heuristic check.
    const isShockLand = !!(ldEntry?.sim_flags?.isShockLand) ||
      (landSubtypes.length === 2 && oracleText.includes('pay 2 life'));

    const hasCondition = oracleText.includes('unless you have two or more opponents') ||
      oracleText.includes('unless you control') ||
      oracleText.includes('unless an opponent');

    // Special land mechanics
    const isAncientTomb = name === 'ancient tomb';
    const isCityOfTraitors = name === 'city of traitors';
    const isPainLand = PAIN_LANDS.has(name);
    const isFiveColorPainLand = FIVE_COLOR_PAIN_LANDS.has(name);

    // Data-driven flags passed through from LAND_DATA (Lands.js)
    // isCrowd: bond/crowd lands â€” ETB condition depends on opponent count
    const isCrowd = CROWD_LANDS.has(name) || !!(ldEntry?.sim_flags?.isCrowd);
    // checkTypes: the specific basic land types a check/reveal/battle land cares about.
    // Using this on the card object lets doesLandEnterTapped avoid re-deriving them from color pairs.
    const checkTypes = ldEntry?.types ?? [];
    // cycleName: display name of the land cycle for reporting / debugging
    const cycleName = ldEntry?.cycleName ?? null;
    // isRoadLand: Aetherdrift road lands (ETB tapped unless controlling an artifact or vehicle)
    const isRoadLand = !!(ldEntry?.sim_flags?.isRoadLand);

    return {
      name: data.name,
      type: 'land',
      isLand: true,
      isBasic,
      isFetch,
      fetchType,
      fetchColors,
      fetchesOnlyBasics,
      fetchesTwoLands,
      fetchedLandEntersTapped,
      isHideawayFetch,
      landSubtypes,
      produces,
      fetchcost, // How much it costs for fetching 
      manaAmount, // How much mana this land produces (1 for normal, 2 for Ancient Tomb/City)
      entersTappedAlways,
      isShockLand,
      hasCondition,
      isBounce,
      isReveal,
      isCheck,
      isFast,
      isBattleLand,
      isPathway,
      isAncientTomb,
      isCityOfTraitors,
      isPainLand,
      isFiveColorPainLand,
      isCrowd,
      checkTypes,   // explicit basic-type array for check/reveal/battle land logic
      cycleName,    // display name of the land cycle (from Lands.js)
      isRoadLand,   // Aetherdrift road lands
      lifeloss: ldEntry?.sim_flags?.lifeloss ?? 0,  // Life paid/lost per use (shock=2, pain/5c=1, ancient tomb=2)
      hasInternalLogic, // Flag: true if land has hardcoded logic, false if pure oracle parsing
      cmc: 0,
      manaCost: '',
      oracleText
    };
  };

  const processManaArtifact = (data) => {
    const cardName = data.name.toLowerCase();
    const oracle   = (data.oracle_text || '').toLowerCase();

    // Look up explicit data from ARTIFACT_DATA (mirrors processRampSpell pattern).
    // Falls back to oracle-text parsing for unknown / community-created cards.
    const known = ARTIFACT_DATA.get(cardName);

    const produces       = known ? known.produces       : extractManaProduction(data.oracle_text);
    const manaAmount     = known ? known.manaAmount     : extractManaAmount(data.oracle_text);
    const entersTapped   = known != null
      ? known.entersTapped
      : (oracle.includes('enters tapped') || oracle.includes('enters the battlefield tapped'));
    const doesntUntapNaturally = known?.doesntUntapNaturally ?? false;

    // ETB cost / condition metadata (stored on the card for use in castSpells)
    const etbCost   = known?.etbCost   ?? null;
    const condition = known?.condition ?? null;

    // Backward-compatible boolean flags derived from map metadata
    const isMoxDiamond    = cardName === 'mox diamond';
    const isChromeMox     = cardName === 'chrome mox';
    const isMoxOpal       = condition === 'metalcraft';
    const isMoxAmber      = condition === 'legendary';
    const isBasaltMonolith = doesntUntapNaturally && cardName === 'basalt monolith';
    const isGrimMonolith   = doesntUntapNaturally && cardName === 'grim monolith';
    const isManaVault      = doesntUntapNaturally && cardName === 'mana vault';

    return {
      name: data.name,
      type: 'artifact',
      isManaArtifact: true,
      produces,
      manaAmount,
      entersTapped,
      isBasaltMonolith,
      isGrimMonolith,
      isManaVault,
      isMoxDiamond,
      isChromeMox,
      isMoxOpal,
      isMoxAmber,
      doesntUntapNaturally,
      etbCost,
      condition,
      cmc: calculateCMC(data.cmc, data.mana_cost),
      manaCost: data.mana_cost || '',
      oracleText: data.oracle_text
    };
  };

  const processManaCreature = (data) => {
    const cardName = data.name.toLowerCase();

    // Look up explicit data from MANA_DORK_DATA; fall back to oracle-text parsing.
    const known = MANA_DORK_DATA.get(cardName);

    const produces    = known ? known.produces    : extractManaProduction(data.oracle_text);
    const manaAmount  = known ? known.manaAmount  : extractManaAmount(data.oracle_text);

    return {
      name: data.name,
      type: 'creature',
      isManaCreature: true,
      produces,
      manaAmount,
      cmc: calculateCMC(data.cmc, data.mana_cost),
      manaCost: data.mana_cost || '',
      oracleText: data.oracle_text
    };
  };

  const processExploration = (data) => {
    // Determine how many lands this allows per turn
    const cardName = data.name.toLowerCase();
    let landsPerTurn = 2; // Default for most exploration effects

    if (cardName.includes('azusa')) {
      landsPerTurn = 3;
    }

    // Check if it's a creature or artifact
    const isCreature = data.type_line?.includes('Creature');
    const isArtifact = data.type_line?.includes('Artifact');

    return {
      name: data.name,
      type: 'exploration',
      isExploration: true,
      isCreature: isCreature,
      isArtifact: isArtifact,
      landsPerTurn: landsPerTurn,
      cmc: calculateCMC(data.cmc, data.mana_cost),
      manaCost: data.mana_cost || '',
      oracleText: data.oracle_text
    };
  };

  const processRampSpell = (data) => {
    const cardName = data.name.toLowerCase();
    const rampData = RAMP_SPELL_DATA.get(cardName) || { landsToAdd: 1, landsTapped: true, landsToHand: 0, sacrificeLand: false, fetchFilter: 'basic' };

    return {
      name: data.name,
      type: 'rampSpell',
      isRampSpell: true,
      landsToAdd: rampData.landsToAdd,
      landsTapped: rampData.landsTapped,
      landsToHand: rampData.landsToHand || 0,
      sacrificeLand: rampData.sacrificeLand || false,
      fetchFilter: rampData.fetchFilter || 'basic',
      fetchSubtypes: rampData.fetchSubtypes || null,
      cmc: calculateCMC(data.cmc, data.mana_cost),
      manaCost: data.mana_cost || '',
      oracleText: data.oracle_text
    };
  };

  const processRitual = (data) => {
    const cardName = data.name.toLowerCase();
    const ritualData = RITUAL_DATA.get(cardName) || { manaProduced: 1, netGain: 0, colors: [] };

    return {
      name: data.name,
      type: 'ritual',
      isRitual: true,
      manaProduced: ritualData.manaProduced,
      netGain: ritualData.netGain,
      ritualColors: ritualData.colors,
      cmc: calculateCMC(data.cmc, data.mana_cost),
      manaCost: data.mana_cost || '',
      oracleText: data.oracle_text
    };
  };

  const processSpell = (data) => {
    // For cards with card_faces (MDFCs, transform cards), we need to get data from the front face
    let cmc = data.cmc;
    let manaCost = data.mana_cost;
    let oracleText = data.oracle_text;
    let typeLine = data.type_line;

    // If card has card_faces and is missing main-level data, use front face
    if (data.card_faces && data.card_faces.length > 0) {
      const frontFace = data.card_faces[0];

      // Use front face data if main card data is missing
      if (cmc === undefined || cmc === null) {
        cmc = frontFace.cmc;
      }
      if (!manaCost && frontFace.mana_cost) {
        manaCost = frontFace.mana_cost;
      }
      if (!oracleText && frontFace.oracle_text) {
        oracleText = frontFace.oracle_text;
      }
      if (!typeLine && frontFace.type_line) {
        typeLine = frontFace.type_line;
      }
    }

    const calculatedCMC = calculateCMC(cmc, manaCost);

    // DEBUG: Log if CMC is 0 to help diagnose
    if (calculatedCMC === 0 && data.name) {
      console.log('âš ï¸ CMC is 0 for:', data.name);
      console.log('  data.cmc:', data.cmc);
      console.log('  data.mana_cost:', data.mana_cost);
      console.log('  final cmc:', cmc);
      console.log('  final manaCost:', manaCost);
      console.log('  has card_faces:', !!data.card_faces);
    }

    return {
      name: data.name,
      type: 'spell',
      cmc: calculatedCMC,
      manaCost: manaCost || '',
      oracleText: oracleText,
      typeLine: typeLine
    };
  };

  const extractManaProduction = (oracleText) => {
    if (!oracleText) return [];

    const produces = [];
    const manaSymbols = oracleText.match(/\{[WUBRGC]\}/g);

    if (manaSymbols) {
      manaSymbols.forEach(symbol => {
        const color = symbol.replace(/[{}]/g, '');
        if (!produces.includes(color)) produces.push(color);
      });
    }

    if (oracleText.includes('any color') || oracleText.includes('mana of any color')) {
      return ['W', 'U', 'B', 'R', 'G'];
    }

    return produces;
  };

  const extractManaAmount = (oracleText) => {
    if (!oracleText) return 1;

    // Count the longest consecutive run of {C} symbols (e.g. {C}{C}{C} â†’ 3).
    // Handles Thran Dynamo, Mana Vault overrides, etc. for unknown cards.
    const colorlessRuns = oracleText.match(/(?:\{C\})+/g);
    if (colorlessRuns) {
      const maxRun = colorlessRuns.reduce((max, run) => {
        const count = run.split('{C}').length - 1;
        return Math.max(max, count);
      }, 0);
      if (maxRun > 1) return maxRun;
    }

    // Default to 1
    return 1;
  };

  const extractRitualManaAmount = (oracleText) => {
    if (!oracleText) return 1;

    // Look for patterns like "Add {B}{B}{B}"
    const manaSymbols = oracleText.match(/Add\s+(\{[WUBRGC]\})+/i);
    if (manaSymbols) {
      const symbols = manaSymbols[0].match(/\{[WUBRGC]\}/g);
      if (symbols) return symbols.length;
    }

    // Look for "add three mana" or "add four mana" patterns
    const wordMatch = oracleText.match(/add\s+(one|two|three|four|five|six|seven)\s+mana/i);
    if (wordMatch) {
      const wordToNum = { one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7 };
      return wordToNum[wordMatch[1].toLowerCase()] || 1;
    }

    // Look for numeric patterns like "add X mana"
    const numMatch = oracleText.match(/add\s+(\d+)\s+mana/i);
    if (numMatch) {
      return parseInt(numMatch[1]) || 1;
    }

    // Default to 1
    return 1;
  };

  const calculateCMC = (dataCmc, manaCostString) => {
    // Start with the provided CMC
    let cmc = dataCmc;

    // If we have a mana cost string, calculate from it
    if (manaCostString) {
      let calculatedCmc = 0;
      const symbols = manaCostString.match(/\{([^}]+)\}/g) || [];

      symbols.forEach(symbol => {
        const clean = symbol.replace(/[{}]/g, '');
        const num = parseInt(clean);

        if (!isNaN(num)) {
          calculatedCmc += num;
        } else if (clean !== 'X' && clean !== 'Y' && clean !== 'Z') {
          calculatedCmc += 1;
        }
      });

      // Use calculated CMC if we don't have a valid dataCmc
      if (cmc === undefined || cmc === null || (cmc === 0 && calculatedCmc > 0)) {
        cmc = calculatedCmc;
      }
    }

    // Convert to integer, default to 0 if all else fails
    const result = parseInt(cmc);

    // Return the result, but if it's NaN, return 0
    return isNaN(result) ? 0 : result;
  };

  // Deck parsing
  const parseDeckList = async (deckText) => {
    const errors = [];
    
    if (!deckText.trim()) {
      errors.push('Please enter a deck list');
      return { errors, lands: [], artifacts: [], creatures: [], exploration: [], rituals: [], rampSpells: [], spells: [], totalCards: 0, landCount: 0 };
    }

    if (cardLookupMap.size === 0 && apiMode === 'local') {
      errors.push('Please upload cards.json file first');
      return { errors, lands: [], artifacts: [], creatures: [], exploration: [], rituals: [], rampSpells: [], spells: [], totalCards: 0, landCount: 0 };
    }

    const lines = deckText.split('\n');
    const cardCounts = new Map();

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.toLowerCase() === 'deck' ||
        trimmed.toLowerCase() === 'sideboard' ||
        trimmed.toLowerCase() === 'commander') {
        continue;
      }

      const match = trimmed.match(/^(\d+)x?\s+(.+)$/);
      if (match) {
        const quantity = parseInt(match[1]);
        const cardName = match[2].trim();

        if (cardCounts.has(cardName)) {
          cardCounts.set(cardName, cardCounts.get(cardName) + quantity);
        } else {
          cardCounts.set(cardName, quantity);
        }
      }
    }

    if (cardCounts.size === 0) {
      errors.push('No valid cards found in deck list');
      return null;
    }

    // Look up all cards
    const lands = [];
    const artifacts = [];
    const creatures = [];
    const rituals = [];
    const rampSpells = [];
    const exploration = [];
    const spells = [];

    for (const [cardName, quantity] of cardCounts.entries()) {
      const cardData = await lookupCard(cardName);

      if (!cardData) {
        errors.push(`Card "${cardName}" not found`);
        continue;
      }

      const processed = processCardData(cardData);

      // Skip if processCardData returned null (e.g., transform lands)
      if (!processed) {
        continue;
      }

      processed.quantity = quantity;

      // Special handling for MDFCs with a land face
      // They should appear in BOTH lands and spells lists
      if (cardData.layout === 'modal_dfc' && cardData.card_faces && cardData.card_faces.length > 0) {
        const frontFace = cardData.card_faces[0];
        const backFace = cardData.card_faces[1];
        const frontIsLand = frontFace.type_line?.toLowerCase().includes('land');
        const backIsLand = backFace.type_line?.toLowerCase().includes('land');

        if (frontIsLand || backIsLand) {
          // Add as land (already done by processCardData)
          lands.push(processed);

          // ALSO add the spell side as a key-card option
          if (frontIsLand && !backIsLand) {
            // Front is land, back is spell - add back as spell
            const spellVersion = processSpell(cardData);
            spellVersion.quantity = quantity;
            spellVersion.name = cardData.name; // Keep full MDFC name
            spellVersion.isMDFCSpellSide = true;
            spells.push(spellVersion);
          } else if (!frontIsLand && backIsLand) {
            // Front is spell, back is land - add front as spell
            const spellVersion = processSpell(cardData);
            spellVersion.quantity = quantity;
            spellVersion.name = cardData.name;
            spellVersion.isMDFCSpellSide = true;
            spells.push(spellVersion);
          }
          continue; // Skip the normal categorization below
        }
      }

      // Normal categorization for non-MDFC cards
      if (processed.isLand) {
        lands.push(processed);
      } else if (processed.isManaArtifact) {
        artifacts.push(processed);
      } else if (processed.isManaCreature) {
        creatures.push(processed);
      } else if (processed.isExploration) {
        exploration.push(processed);
      } else if (processed.isRitual) {
        rituals.push(processed);
      } else if (processed.isRampSpell) {
        rampSpells.push(processed);
      } else {
        spells.push(processed);
      }
    }

    setError(errors.length > 0 ? errors.join(', ') : '');

    const totalCards = [...lands, ...artifacts, ...creatures, ...exploration, ...rituals, ...rampSpells, ...spells]
      .reduce((sum, card) => sum + card.quantity, 0);

    return {
      lands,
      artifacts,
      creatures,
      exploration,
      rituals,
      rampSpells,
      spells,
      totalCards,
      landCount: lands.reduce((sum, card) => sum + card.quantity, 0),
      errors: errors
    };
  };

  const handleParseDeck = async () => {
    const deck = await parseDeckList(deckText);
    if (deck) {
      setParsedDeck(deck);
      if (deck.errors && deck.errors.length > 0) {
        setError(deck.errors.join(', '));
      } else {
        setError('');
      }
    } else {
      setParsedDeck(null);
      setError('Parsing failed');
    }
  };

  // Simulation functions
  const shuffle = (array) => {
    const arr = [...array];
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };

  const buildCompleteDeck = (deckToParse) => {
    if (!deckToParse) return [];

    // Use deck-specific toggles
    const includeArts = includeArtifacts;
    const disabledArts = disabledArtifacts;
    const includeCreats = includeCreatures;
    const disabledCreats = disabledCreatures;
    const includeExplor = includeExploration;
    const disabledExplor = disabledExploration;
    const includeRamp = includeRampSpells;
    const disabledRamp = disabledRampSpells;
    const includeRits = includeRituals;
    const disabledRits = disabledRituals;

    const deck = [];

    deckToParse.lands.forEach(card => {
      for (let i = 0; i < card.quantity; i++) {
        deck.push({ ...card });
      }
    });

    if (includeArts) {
      deckToParse.artifacts.forEach(card => {
        if (!disabledArts.has(card.name)) {
          for (let i = 0; i < card.quantity; i++) {
            deck.push({ ...card });
          }
        }
      });
    }

    if (includeCreats) {
      deckToParse.creatures.forEach(card => {
        if (!disabledCreats.has(card.name)) {
          for (let i = 0; i < card.quantity; i++) {
            deck.push({ ...card });
          }
        }
      });
    }

    if (includeExplor && deckToParse.exploration) {
      deckToParse.exploration.forEach(card => {
        if (!disabledExplor.has(card.name)) {
          for (let i = 0; i < card.quantity; i++) {
            deck.push({ ...card });
          }
        }
      });
    }

    if (includeRamp && deckToParse.rampSpells) {
      deckToParse.rampSpells.forEach(card => {
        if (!disabledRamp.has(card.name)) {
          for (let i = 0; i < card.quantity; i++) {
            deck.push({ ...card });
          }
        }
      });
    }

    if (includeRits && deckToParse.rituals) {
      deckToParse.rituals.forEach(card => {
        if (!disabledRits.has(card.name)) {
          for (let i = 0; i < card.quantity; i++) {
            deck.push({ ...card });
          }
        }
      });
    }

    deckToParse.spells.forEach(card => {
      for (let i = 0; i < card.quantity; i++) {
        deck.push({ ...card });
      }
    });

    return deck;
  };

  const runSimulation = () => {
    if (!parsedDeck) {
      setError('Please parse a deck first');
      return;
    }

    // Check if deck 2 is needed for comparison

    setIsSimulating(true);
    setError('');

    setTimeout(() => {
      try {
        // Run simulation for deck 1
        const results1 = monteCarlo(parsedDeck);
        setSimulationResults(results1);

        // Run simulation for deck 2 if comparison mode

        setIsSimulating(false);
      } catch (err) {
        setError('Simulation error: ' + err.message);
        setIsSimulating(false);
      }
    }, 100);
  };

  const monteCarlo = (deckToParse) => {
    const deck = buildCompleteDeck(deckToParse);
    const keyCardNames = Array.from(selectedKeyCards);

    const results = {
      landsPerTurn: Array(turns).fill(null).map(() => []),
      untappedLandsPerTurn: Array(turns).fill(null).map(() => []),
      colorsByTurn: Array(turns).fill(null).map(() => ({ W: [], U: [], B: [], R: [], G: [] })),
      totalManaPerTurn: Array(turns).fill(null).map(() => []),
      lifeLossPerTurn: Array(turns).fill(null).map(() => []),
      keyCardPlayability: {},
      keyCardPlayabilityBurst: {},
      hasBurstCards: false,
      fastestPlaySequences: {},
      fastestPlaySequencesBurst: {},
      mulligans: 0,
      handsKept: 0
    };

    keyCardNames.forEach(name => {
      results.keyCardPlayability[name] = Array(turns).fill(0);
      results.keyCardPlayabilityBurst[name] = Array(turns).fill(0);
    });

    // Detect burst cards once from deck composition (not per-hand, so hasBurstCards
    // is set even when the burst card isn't drawn into every opening hand).
    results.hasBurstCards =
      [...deckToParse.spells, ...(deckToParse.artifacts || [])].some(
        c => BURST_MANA_SOURCES.has(c.name?.toLowerCase())
      ) ||
      (deckToParse.rituals && deckToParse.rituals.length > 0);

    for (let iter = 0; iter < iterations; iter++) {
      const shuffled = shuffle(deck);
      let hand = shuffled.slice(0, handSize);
      let library = shuffled.slice(handSize);

      // Mulligan logic
      let mulliganCount = 0;
      const maxMulligans = 6;

      if (enableMulligans) {
        let shouldMulligan = true;

        while (shouldMulligan && mulliganCount < maxMulligans) {
          shouldMulligan = false;
          const landCount = hand.filter(c => c.isLand).length;

          // Determine if we should mulligan based on strategy
          if (mulliganStrategy === 'conservative') {
            // Conservative: only mulligan extreme hands (0 or 7 lands)
            if (landCount === 0 || landCount === 7) {
              shouldMulligan = true;
            }
          } else if (mulliganStrategy === 'balanced') {
            // Balanced: mulligan 0/7 lands, or hands with no plays by turn 3
            if (landCount === 0 || landCount === 7) {
              shouldMulligan = true;
            } else if (landCount < 2 || landCount > 5) {
              // Check if we have any 2-drops or less
              const hasEarlyPlay = hand.some(c => !c.isLand && (c.cmc || 0) <= 2);
              if (!hasEarlyPlay) {
                shouldMulligan = true;
              }
            }
          } else if (mulliganStrategy === 'aggressive') {
            // Aggressive: mulligan aggressively for ideal hands
            if (landCount < 2 || landCount > 4) {
              shouldMulligan = true;
            }
          } else if (mulliganStrategy === 'custom') {
            // Custom: use user-defined rules
            if (customMulliganRules.mulligan0Lands && landCount === 0) {
              shouldMulligan = true;
            }
            if (customMulliganRules.mulligan7Lands && landCount === 7) {
              shouldMulligan = true;
            }
            if (customMulliganRules.mulliganMinLands && landCount < customMulliganRules.minLandsThreshold) {
              shouldMulligan = true;
            }
            if (customMulliganRules.mulliganMaxLands && landCount > customMulliganRules.maxLandsThreshold) {
              shouldMulligan = true;
            }
            if (customMulliganRules.mulliganNoPlaysByTurn) {
              // Simulate first N turns to check for plays
              // For simplicity, check if we have castable spells
              const hasEarlyPlay = hand.some(c =>
                !c.isLand && (c.cmc || 0) <= customMulliganRules.noPlaysTurnThreshold
              );
              if (!hasEarlyPlay) {
                shouldMulligan = true;
              }
            }
          }

          if (shouldMulligan) {
            mulliganCount++;
            results.mulligans++;

            if (mulliganRule === 'london') {
              // London Mulligan: Draw 7, then put N cards on bottom (where N = mulligan count)
              const newShuffle = shuffle(deck);
              const newHand = newShuffle.slice(0, 7);

              // Put mulliganCount cards on bottom (for simplicity, put worst cards)
              // Prefer non-lands if we have too many lands, lands if we have too few
              const cardsToBottom = mulliganCount;
              const sortedHand = [...newHand].sort((a, b) => {
                const landCount = newHand.filter(c => c.isLand).length;
                if (landCount > 4) {
                  // Too many lands - bottom lands first
                  if (a.isLand && !b.isLand) return -1;
                  if (!a.isLand && b.isLand) return 1;
                } else if (landCount < 2) {
                  // Too few lands - bottom non-lands first
                  if (!a.isLand && b.isLand) return -1;
                  if (a.isLand && !b.isLand) return 1;
                }
                // Otherwise sort by CMC (highest first)
                return (b.cmc || 0) - (a.cmc || 0);
              });

              hand = sortedHand.slice(cardsToBottom);
              library = newShuffle.slice(7);
            } else {
              // Vancouver Mulligan: Draw one fewer card
              const newShuffle = shuffle(deck);
              const newHandSize = 7 - mulliganCount;
              hand = newShuffle.slice(0, newHandSize);
              library = newShuffle.slice(newHandSize);
            }
          }
        }
      }

      results.handsKept++;

      const battlefield = [];
      const graveyard = [];
      let cumulativeLifeLoss = 0;
      const turnActions = [];
      const openingHand = hand.map(c => c.name);

      for (let turn = 0; turn < turns; turn++) {
        const turnLog = { turn: turn + 1, actions: [], lifeLoss: 0 };

        // Untap phase
        battlefield.forEach(p => {
          // Grim Monolith and Mana Vault don't untap during untap step
          if (p.card.doesntUntapNaturally) {
            // Keep tapped
            return;
          }

          p.tapped = false;
          if (p.summoningSick !== undefined) {
            p.summoningSick = false;
          }
        });

        // Upkeep: Mana Vault damage
        let manaVaultDamage = 0;
        battlefield.forEach(p => {
          if (p.card.isManaVault && p.tapped) {
            // Mana Vault deals 1 damage if it's tapped during upkeep
            // (player can pay {4} to untap, but we don't simulate that for now)
            manaVaultDamage += 1;
          }
        });
        turnLog.lifeLoss += manaVaultDamage;
        cumulativeLifeLoss += manaVaultDamage;

        // Draw phase
        // Commander Mode: Draw on turn 0 (multiplayer convention - everyone draws)
        // Standard Mode: Skip draw on turn 0 (on the play)
        const shouldDraw = turn > 0 || commanderMode;

        if (shouldDraw && library.length > 0) {
          const drawn = library.shift();
          hand.push(drawn);
          turnLog.actions.push(`Drew: ${drawn.name}`);
        }

        // PHASE 1: Play the first land (normal land drop)
        let landsPlayedThisTurn = 0;
        const firstLand = selectBestLand(hand, battlefield, library, turn);
        if (firstLand) {
          const lifeLoss = playLand(firstLand, hand, battlefield, library, graveyard, turn, turnLog, keyCardNames, deckToParse);
          turnLog.lifeLoss += lifeLoss;
          cumulativeLifeLoss += lifeLoss;

          if (lifeLoss > 0 && turnLog) {
            const lastAction = turnLog.actions[turnLog.actions.length - 1];
            if (lastAction && !lastAction.includes('Cannot play')) {
              turnLog.actions[turnLog.actions.length - 1] = `${lastAction} [-${lifeLoss} life]`;
            }
          }

          landsPlayedThisTurn++;
        }

        // PHASE 2: Cast Exploration effects AFTER the first land is played
        if (includeExploration) {
          const manaAvailable = calculateManaAvailability(battlefield);
          const explorationInHand = hand.filter(c => c.isExploration && !disabledExploration.has(c.name));

          for (const exploration of explorationInHand) {
            if (canPlayCard(exploration, manaAvailable)) {
              const index = hand.indexOf(exploration);
              hand.splice(index, 1);

              battlefield.push({
                card: exploration,
                tapped: exploration.entersTapped || false,
                summoningSick: exploration.isManaCreature || false // Only creatures have summoning sickness for mana
              });

              tapManaSources(exploration, battlefield);

              if (turnLog) {
                const type = exploration.isCreature ? 'creature' : (exploration.isArtifact ? 'artifact' : 'permanent');
                turnLog.actions.push(`Cast ${type}: ${exploration.name} (Exploration effect)`);
              }

              // Recalculate mana after casting
              const newMana = calculateManaAvailability(battlefield);
              Object.assign(manaAvailable, newMana);
            }
          }
        }

        // PHASE 3: Determine max lands per turn (NOW includes exploration cast this turn)
        let maxLandsPerTurn = 1;
        if (includeExploration) {
          battlefield.forEach(p => {
            // Check if this is an exploration effect card
            if (p.card.isExploration && !disabledExploration.has(p.card.name)) {
              maxLandsPerTurn = Math.max(maxLandsPerTurn, p.card.landsPerTurn || 2);
            }
          });
        }

        // PHASE 4: Play additional lands beyond the first (if exploration effects allow it)
        while (landsPlayedThisTurn < maxLandsPerTurn) {
          const landInHand = selectBestLand(hand, battlefield, library, turn);
          if (!landInHand) break;

          const lifeLoss = playLand(landInHand, hand, battlefield, library, graveyard, turn, turnLog, keyCardNames, deckToParse);
          turnLog.lifeLoss += lifeLoss;
          cumulativeLifeLoss += lifeLoss;

          if (lifeLoss > 0 && turnLog) {
            const lastAction = turnLog.actions[turnLog.actions.length - 1];
            if (lastAction && !lastAction.includes('Cannot play')) {
              turnLog.actions[turnLog.actions.length - 1] = `${lastAction} [-${lifeLoss} life]`;
            }
          }

          landsPlayedThisTurn++;
        }

        // PHASE 5: Activate fetch lands (lands already in play)
        const fetchLands = battlefield.filter(p => p.card.isFetch && !p.tapped);
        for (const fetchPermanent of fetchLands) {
          // Check if we can afford the fetch cost
          const manaAvailable = calculateManaAvailability(battlefield);
          const fetchCost = fetchPermanent.card.fetchcost || 0;

          // For free fetches (fetchcost = 0), no mana needed regardless of fetchType.
          // classic / slow / auto_sacrifice / colorless_or_fetch all cost 0 and are free to activate.
          // For mana_cost fetches we need to have enough total mana.
          let canAffordFetch = false;

          if (fetchCost === 0) {
            // No activation cost â€” classic fetches, Evolving Wilds, hideaway auto-sacrifices, etc.
            canAffordFetch = true;
          } else if (fetchCost > 0 && manaAvailable.total >= fetchCost) {
            // Can afford the generic mana cost (panoramas, landscapes, Myriad Landscape, etc.)
            canAffordFetch = true;
          }

          if (!canAffordFetch) {
            // Can't afford the fetch, skip it
            continue;
          }

          // Pay the mana cost by tapping sources
          let manaStillNeeded = fetchCost;
          const originalbattlefield = [...battlefield];

          // Tap untapped lands/permanents to pay for the fetch
          if (manaStillNeeded > 0) {
            const untappedSources = battlefield.filter(p => 
              !p.tapped && p.card.isLand && p !== fetchPermanent
            );

            for (const source of untappedSources) {
              if (manaStillNeeded <= 0) break;
              source.tapped = true;
              manaStillNeeded -= source.card.manaAmount || 1;
            }
          }

          const fetchedLand = findBestLandToFetch(fetchPermanent.card, library, battlefield, keyCardNames, deckToParse, turn);
          if (fetchedLand) {
            const libIndex = library.indexOf(fetchedLand);
            library.splice(libIndex, 1);

            // Check if the FETCH determines tapped state, otherwise check the land itself
            let entersTapped;
            if (fetchPermanent.card.fetchedLandEntersTapped) {
              // Fetch says land enters tapped (e.g., Terramorphic Expanse)
              entersTapped = true;
            } else {
              // Check if land itself enters tapped (e.g., shock lands)
              entersTapped = doesLandEnterTapped(fetchedLand, battlefield, turn, commanderMode);
            }

            const fetchIndex = battlefield.indexOf(fetchPermanent);
            battlefield.splice(fetchIndex, 1);
            graveyard.push(fetchPermanent.card);

            battlefield.push({
              card: fetchedLand,
              tapped: entersTapped,
              enteredTapped: entersTapped
            });

            // Shock land decision
            if (fetchedLand.isShockLand && turn <= 6 && entersTapped && !fetchPermanent.card.fetchedLandEntersTapped) {
              battlefield[battlefield.length - 1].tapped = false;
              battlefield[battlefield.length - 1].enteredTapped = false;
              const shockCost = fetchedLand.lifeloss ?? 2;
              cumulativeLifeLoss += shockCost;
              turnLog.lifeLoss += shockCost;
            }

            // Fetch land cost (life loss for classic fetches only: Onslaught/Zendikar 10 + Prismatic Vista)
            // Slow fetches (Mirage: Flood Plain, Bad River, etc.) do NOT pay life.
            if (fetchPermanent.card.fetchType === 'classic') {
              cumulativeLifeLoss += 1;
              turnLog.lifeLoss += 1;
            }

            if (turnLog) {
              const finalState = battlefield[battlefield.length - 1]?.tapped ? 'tapped' : 'untapped';
              const lifeCost = fetchPermanent.card.fetchType === 'classic' ? ' [-1 life]' : '';
              turnLog.actions.push(`Fetched ${fetchedLand.name} (${finalState})${lifeCost}`);
            }
          } else {
            // No valid fetch targets in library â€” log so it's visible in the turn breakdown
            if (turnLog) {
              turnLog.actions.push(`${fetchPermanent.card.name} activated but no valid fetch targets in library`);
            }
          }
        }

        // PHASE 6: Cast remaining spells (mana dorks, artifacts, etc.)
        castSpells(hand, battlefield, graveyard, turnLog, keyCardNames, deckToParse, library, turn);

        // Mana Crypt: coin-flip upkeep trigger â€” 50% chance of 3 damage = 1.5 avg per turn.
        const manaCryptCount = battlefield.filter(p =>
          p.card.isManaArtifact && p.card.name?.toLowerCase() === 'mana crypt'
        ).length;
        const manaCryptDamage = manaCryptCount * 1.5;

        if (manaCryptDamage > 0) {
          cumulativeLifeLoss += manaCryptDamage;
          turnLog.lifeLoss += manaCryptDamage;
          turnLog.actions.push(`Mana Crypt damage: -${manaCryptDamage} life (avg)`);
        }

        // Ancient Tomb: deals 2 damage per turn (regardless of tapped state)
        const ancientTombDamage = battlefield
          .filter(p => p.card.isLand && p.card.isAncientTomb)
          .reduce((sum, p) => sum + (p.card.lifeloss ?? 2), 0);

        if (ancientTombDamage > 0) {
          cumulativeLifeLoss += ancientTombDamage;
          turnLog.lifeLoss += ancientTombDamage;
          turnLog.actions.push(`Ancient Tomb damage: -${ancientTombDamage} life`);
        }

        // Starting Town: deals 1 damage per turn at upkeep
        const startingTownDamage = battlefield
          .filter(p => p.card.isLand && p.card.name === 'starting town')
          .reduce((sum, p) => sum + (p.card.lifeloss ?? 1), 0);

        if (startingTownDamage > 0) {
          cumulativeLifeLoss += startingTownDamage;
          turnLog.lifeLoss += startingTownDamage;
          turnLog.actions.push(`Starting Town damage: -${startingTownDamage} life`);
        }

        // Pain Lands: deal 1 damage when tapped for colored mana
        // Simplified: assume all pain lands deal damage each turn (turns 1-5)
        const painLandDamage = battlefield
          .filter(p => p.card.isLand && p.card.isPainLand)
          .reduce((sum, p) => sum + (p.card.lifeloss ?? 1), 0);

        if (painLandDamage > 0 && turn <= 5) {
          cumulativeLifeLoss += painLandDamage;
          turnLog.lifeLoss += painLandDamage;
          turnLog.actions.push(`Pain Land damage: -${painLandDamage} life`);
        }

        // 5-Color Pain Lands (Mana Confluence, City of Brass): deal 1 damage when tapped
        const fiveColorPainDamage = battlefield
          .filter(p => p.card.isLand && p.card.isFiveColorPainLand && p.tapped)
          .reduce((sum, p) => sum + (p.card.lifeloss ?? 1), 0);

        if (fiveColorPainDamage > 0) {
          cumulativeLifeLoss += fiveColorPainDamage;
          turnLog.lifeLoss += fiveColorPainDamage;
          turnLog.actions.push(`5-Color Pain Land damage: -${fiveColorPainDamage} life`);
        }

        turnActions.push(turnLog);

        // Track statistics
        const landCount = battlefield.filter(p => p.card.isLand).length;
        const untappedLandCount = battlefield.filter(p => p.card.isLand && !p.tapped).length;

        results.landsPerTurn[turn].push(landCount);
        results.untappedLandsPerTurn[turn].push(untappedLandCount);
        results.lifeLossPerTurn[turn].push(cumulativeLifeLoss);

        // Calculate mana availability
        const manaAvailable = calculateManaAvailability(battlefield);
        results.totalManaPerTurn[turn].push(manaAvailable.total);

        // Only track W, U, B, R, G (not colorless)
        ['W', 'U', 'B', 'R', 'G'].forEach(color => {
          results.colorsByTurn[turn][color].push(manaAvailable.colors[color] || 0);
        });

        // Burst mana from one-shot sources in hand (optimistic model: no drawbacks).
        // hasBurstCards is pre-set from deck composition â€” no need to update it here.
        const burstInHand = hand.filter(c => BURST_MANA_SOURCES.has(c.name?.toLowerCase()));
        const burstFromArtifacts = burstInHand.reduce((sum, c) => {
          const known = ARTIFACT_DATA.get(c.name?.toLowerCase());
          return sum + (known?.manaAmount ?? 1);
        }, 0);
        // Rituals in hand contribute their net mana gain only when their casting cost
        // is affordable this turn (e.g. Dark Ritual needs â‰¥1B, Seething Song needs â‰¥3 incl. 1R).
        const ritualsInHand = hand.filter(c => c.isRitual && canPlayCard(c, manaAvailable));
        const burstFromRituals = ritualsInHand.reduce((sum, c) => sum + (c.netGain || 0), 0);
        const burstTotal = burstFromArtifacts + burstFromRituals;

        // Build per-color burst bonus:
        //   Artifact burst sources (LED, Jeweled Lotus, Lotus Petal) produce any color.
        //   Ritual spells only produce their specific colors (e.g. Dark Ritual â†’ B only).
        const burstColorBonus = { W: 0, U: 0, B: 0, R: 0, G: 0, C: 0 };
        burstInHand.forEach(c => {
          const known = ARTIFACT_DATA.get(c.name?.toLowerCase());
          const amt = known?.manaAmount ?? 1;
          ['W', 'U', 'B', 'R', 'G'].forEach(col => { burstColorBonus[col] += amt; });
        });
        ritualsInHand.forEach(c => {
          const colors = c.ritualColors;
          const gain = c.netGain || 0;
          if (colors && colors.length > 0) {
            colors.forEach(col => { if (col in burstColorBonus) burstColorBonus[col] += gain; });
          } else {
            // Fallback: colorless rituals add to all colors
            ['W', 'U', 'B', 'R', 'G'].forEach(col => { burstColorBonus[col] += gain; });
          }
        });

        const manaWithBurst = burstTotal > 0 ? {
          total: manaAvailable.total + burstTotal,
          colors: Object.fromEntries(
            Object.entries(manaAvailable.colors).map(([k, v]) =>
              [k, v + (burstColorBonus[k] || 0)]
            )
          )
        } : manaAvailable;

        // Check key card playability
        keyCardNames.forEach(cardName => {
          // Find the key card in deckToParse
          const keyCard = deckToParse.spells.find(c => c.name === cardName) ||
            deckToParse.creatures.find(c => c.name === cardName) ||
            deckToParse.artifacts.find(c => c.name === cardName) ||
            (deckToParse.rampSpells && deckToParse.rampSpells.find(c => c.name === cardName)) ||
            (deckToParse.exploration && deckToParse.exploration.find(c => c.name === cardName));

          if (keyCard && canPlayCard(keyCard, manaAvailable)) {
            results.keyCardPlayability[cardName][turn]++;

            // Track play sequences by turn (base mana only)
            if (!results.fastestPlaySequences[cardName]) {
              results.fastestPlaySequences[cardName] = {};
            }
            const currentTurn = turn + 1;
            if (!results.fastestPlaySequences[cardName][currentTurn]) {
              results.fastestPlaySequences[cardName][currentTurn] = [];
            }
            if (results.fastestPlaySequences[cardName][currentTurn].length < maxSequences) {
              results.fastestPlaySequences[cardName][currentTurn].push({
                turn: currentTurn,
                manaAvailable: manaAvailable.total,
                sequence: JSON.parse(JSON.stringify(turnActions)),
                openingHand: [...openingHand]
              });
            }
          }

          // Burst check â€” does burst mana (optimistic) allow playing this card?
          if (keyCard && canPlayCard(keyCard, manaWithBurst)) {
            results.keyCardPlayabilityBurst[cardName][turn]++;

            // Only record a burst sequence when base mana alone isn't enough.
            // This highlights cases where a burst card actually makes the difference.
            if (!canPlayCard(keyCard, manaAvailable)) {
              if (!results.fastestPlaySequencesBurst[cardName]) {
                results.fastestPlaySequencesBurst[cardName] = {};
              }
              const currentTurnBurst = turn + 1;
              if (!results.fastestPlaySequencesBurst[cardName][currentTurnBurst]) {
                results.fastestPlaySequencesBurst[cardName][currentTurnBurst] = [];
              }
              if (results.fastestPlaySequencesBurst[cardName][currentTurnBurst].length < maxSequences) {
                results.fastestPlaySequencesBurst[cardName][currentTurnBurst].push({
                  turn: currentTurnBurst,
                  manaAvailable: manaAvailable.total,
                  manaWithBurst: manaWithBurst.total,
                  burstCards: [
                    ...burstInHand.map(c => c.name),
                    ...ritualsInHand.map(c => c.name)
                  ],
                  sequence: JSON.parse(JSON.stringify(turnActions)),
                  openingHand: [...openingHand]
                });
              }
            }
          }
        });
      }
    }

    // Calculate averages
    for (let turn = 0; turn < turns; turn++) {
      results.landsPerTurn[turn] = average(results.landsPerTurn[turn]);
      results.untappedLandsPerTurn[turn] = average(results.untappedLandsPerTurn[turn]);
      results.totalManaPerTurn[turn] = average(results.totalManaPerTurn[turn]);
      results.lifeLossPerTurn[turn] = average(results.lifeLossPerTurn[turn]);

      Object.keys(results.colorsByTurn[turn]).forEach(color => {
        results.colorsByTurn[turn][color] = average(results.colorsByTurn[turn][color]);
      });
    }

    // Calculate key card percentages (base and burst)
    Object.keys(results.keyCardPlayability).forEach(cardName => {
      results.keyCardPlayability[cardName] = results.keyCardPlayability[cardName].map(
        count => (count / results.handsKept) * 100
      );
    });
    Object.keys(results.keyCardPlayabilityBurst).forEach(cardName => {
      results.keyCardPlayabilityBurst[cardName] = results.keyCardPlayabilityBurst[cardName].map(
        count => (count / results.handsKept) * 100
      );
    });

    return results;
  };

  const selectBestLand = (hand, battlefield, library, turn) => {
    const lands = hand.filter(c => c.isLand);
    if (lands.length === 0) return null;

    // For each bounce land in hand, check if there's a NON-BOUNCE land to bounce
    const landsWithBouncability = lands.map(land => {
      // Defensive check: Also check by name if isBounce flag is missing
      const isBounceCard = land.isBounce || BOUNCE_LANDS.has(land.name.toLowerCase());

      if (!isBounceCard) {
        return { land, canPlay: true };
      }

      // Check if there's a non-bounce land on battlefield to bounce
      const nonBounceLandsToReturn = battlefield.filter(p =>
        p.card.isLand &&
        !p.card.isBounce &&
        !BOUNCE_LANDS.has(p.card.name.toLowerCase())
      );

      return {
        land,
        canPlay: nonBounceLandsToReturn.length > 0
      };
    });

    const playableLands = landsWithBouncability
      .filter(item => item.canPlay)
      .map(item => item.land);

    if (playableLands.length === 0) return null;

    // Priority: fetch (mana costing fetches only if mana available)> untapped non-bounce >bounce (with non-bounce available) > tapped
    const fetches = playableLands.filter(l => l.isFetch && l.fetchType !== 'mana_cost');
    const untappedLands = battlefield.filter(d => d.isLand && !d.tapped);
    if (fetches.length > 0 && untappedLands.length >= fetches[0].fetchcost) return fetches[0];

    const untappedNonBounce = playableLands.filter(l =>
      !l.entersTappedAlways &&
      !l.isBounce &&
      !BOUNCE_LANDS.has(l.name.toLowerCase())
    );
    if (untappedNonBounce.length > 0) return untappedNonBounce[0];

    const bouncelands = playableLands.filter(l =>
      l.isBounce || BOUNCE_LANDS.has(l.name.toLowerCase())
    );
    if (bouncelands.length > 0) return bouncelands[0];

    return playableLands[0];
  };

  const playLand = (land, hand, battlefield, library, graveyard, turn, turnLog, keyCardNames, parsedDeck) => {
    const index = hand.indexOf(land);
    hand.splice(index, 1);

    let lifeLoss = 0;

    // City of Traitors: Sacrifice when you play another land
    const cityOfTraitorsInPlay = battlefield.filter(p =>
      p.card.isLand && p.card.isCityOfTraitors
    );

    if (cityOfTraitorsInPlay.length > 0 && !land.isCityOfTraitors) {
      // Sacrifice all City of Traitors
      cityOfTraitorsInPlay.forEach(city => {
        const cityIndex = battlefield.indexOf(city);
        battlefield.splice(cityIndex, 1);
        graveyard.push(city.card);

        if (turnLog) {
          turnLog.actions.push(`Sacrificed ${city.card.name} (another land played)`);
        }
      });
    }
    if (land.isFetch) {
      // Hideaway fetch lands (Maestros Theater, etc.) - special handling
      if (land.isHideawayFetch) {
        // Hideaway lands enter tapped, then immediately sacrifice to fetch a basic tapped
        const fetchedLand = findBestLandToFetch(land, library, battlefield, keyCardNames, parsedDeck, turn);

        if (fetchedLand) {
          const libIndex = library.indexOf(fetchedLand);
          library.splice(libIndex, 1);

          // Fetched land enters tapped
          battlefield.push({
            card: fetchedLand,
            tapped: true,
            enteredTapped: true
          });

          // The hideaway land goes to graveyard (sacrificed)
          graveyard.push(land);

          if (turnLog) {
            turnLog.actions.push(`Played ${land.name}, sacrificed it to fetch ${fetchedLand.name} (tapped)`);
          }
        } else {
          // No valid fetch target, play as regular land (enters tapped)
          battlefield.push({
            card: land,
            tapped: true,
            enteredTapped: true
          });

          if (turnLog) {
            turnLog.actions.push(`Played ${land.name} (tapped, no fetch targets)`);
          }
        }
      }
      // Regular fetch land logic 
      else {
        const entersTapped = doesLandEnterTapped(land, battlefield, turn, commanderMode);
        battlefield.push({
          card: land,
          tapped: entersTapped,
          enteredTapped: entersTapped
        });
        if (turnLog) {
          const finalState = battlefield[battlefield.length - 1]?.tapped ? 'tapped' : 'untapped';
          turnLog.actions.push(`Played ${land.name} (fetch land, ${finalState})`);
        }
      }
    }
    else {
      // Regular land
      const entersTapped = doesLandEnterTapped(land, battlefield, turn, commanderMode);

      // Defensive check: Also check by name if isBounce flag is missing
      const isBounceCard = land.isBounce || BOUNCE_LANDS.has(land.name.toLowerCase());

      // Bounce land mechanic - check BEFORE adding to battlefield
      if (isBounceCard) {
        // Check if there are OTHER lands to bounce (before we add this one)
        const landsToBounce = battlefield.filter(p =>
          p.card.isLand && !p.card.isBounce && !BOUNCE_LANDS.has(p.card.name.toLowerCase())
        );

        if (landsToBounce.length === 0) {
          // Cannot play bounce land without another NON-BOUNCE land to bounce
          if (turnLog) {
            turnLog.actions.push(`Cannot play ${land.name} (no non-bounce lands to bounce)`);
          }

          return 0; // No life loss, don't play the land at all
        }
      }

      // Now add the land to battlefield
      battlefield.push({
        card: land,
        tapped: entersTapped,
        enteredTapped: entersTapped
      });

      // Shock land decision
      if (land.isShockLand && turn <= 6 && entersTapped) {
        battlefield[battlefield.length - 1].tapped = false;
        battlefield[battlefield.length - 1].enteredTapped = false;
        lifeLoss += (land.lifeloss ?? 2);
      }

      // Bounce land mechanic - execute the bounce AFTER adding to battlefield
      if (isBounceCard) {
        // Get the state of the bounce land BEFORE bouncing
        const bounceLandIndex = battlefield.length - 1;
        const finalState = battlefield[bounceLandIndex]?.tapped ? 'tapped' : 'untapped';

        // Find non-bounce lands to bounce
        const landsToBounce = battlefield.filter(p =>
          p.card.isLand && !p.card.isBounce && !BOUNCE_LANDS.has(p.card.name.toLowerCase())
        );

        // Prefer bouncing tapped lands
        const tappedLands = landsToBounce.filter(p => p.tapped);
        const toBounce = tappedLands.length > 0 ? tappedLands[0] : landsToBounce[0];
        const bouncedState = toBounce.tapped ? 'tapped' : 'untapped';

        const bounceIndex = battlefield.indexOf(toBounce);
        battlefield.splice(bounceIndex, 1);
        hand.push(toBounce.card);

        // Log play + bounce as single action
        if (turnLog) {
          turnLog.actions.push(`Played ${land.name} (${finalState}), bounced ${toBounce.card.name} (${bouncedState})`);
        }
      } else {
        // Regular land without bounce
        if (turnLog) {
          const finalState = battlefield[battlefield.length - 1]?.tapped ? 'tapped' : 'untapped';
          turnLog.actions.push(`Played ${land.name} (${finalState})`);
        }
      }
    }

    return lifeLoss;
  };

  const findBestLandToFetch = (fetchLand, library, battlefield, keyCardNames, parsedDeck, turn) => {
    // For hideaway fetches and basic-only fetches, only fetch basic lands
    const onlyBasics = fetchLand.isHideawayFetch || fetchLand.fetchesOnlyBasics;

    const eligibleLands = library.filter(card => {
      if (!card.isLand) return false;

      // If this fetch only gets basics, check if the land is basic
      if (onlyBasics && !card.isBasic) {
        return false;
      }

      const landTypes = card.landSubtypes || [];
      const fetchColors = fetchLand.fetchColors || [];

      return landTypes.some(type => {
        const typeToColor = {
          'Plains': 'W', 'Island': 'U', 'Swamp': 'B', 'Mountain': 'R', 'Forest': 'G'
        };
        return fetchColors.includes(typeToColor[type]);
      });
    });

    if (eligibleLands.length === 0) return null;

    // Determine what colors we need for key cards
    const neededColors = new Set();

    if (keyCardNames && keyCardNames.length > 0 && parsedDeck) {
      // Find key cards and sort by CMC (lower CMC = higher priority)
      const keyCards = [];
      keyCardNames.forEach(cardName => {
        const card = parsedDeck.spells.find(c => c.name === cardName) ||
          parsedDeck.creatures.find(c => c.name === cardName) ||
          parsedDeck.artifacts.find(c => c.name === cardName);
        if (card) keyCards.push(card);
      });

      keyCards.sort((a, b) => a.cmc - b.cmc);

      // Get colors needed for key cards (prioritize lower CMC cards)
      keyCards.forEach(card => {
        const symbols = card.manaCost.match(/\{([^}]+)\}/g) || [];
        symbols.forEach(symbol => {
          const clean = symbol.replace(/[{}]/g, '');
          if (['W', 'U', 'B', 'R', 'G'].includes(clean)) {
            neededColors.add(clean);
          }
        });
      });
    }

    // Calculate what colors we already have
    const currentColors = new Set();
    battlefield.forEach(permanent => {
      if (permanent.card.isLand || permanent.card.isManaArtifact ||
        (permanent.card.isManaCreature && !permanent.summoningSick)) {
        (permanent.card.produces || []).forEach(color => {
          if (['W', 'U', 'B', 'R', 'G'].includes(color)) {
            currentColors.add(color);
          }
        });
      }
    });

    // Find missing colors (colors needed but not available)
    const missingColors = new Set();
    neededColors.forEach(color => {
      if (!currentColors.has(color)) {
        missingColors.add(color);
      }
    });

    // Score lands based on priority
    const scoredLands = eligibleLands.map(land => {
      let score = 0;

      // Highest priority: lands that produce missing colors
      const producesNeededColor = (land.produces || []).some(color => missingColors.has(color));

      if (producesNeededColor) {
        score += 300;
      }

      // Bonus for early triomes
      if (turn <= 2 && ((land.produces || []).length > 2)) {
        score += 1000;
      }

      // Bonus for not shock late
      if (turn >= 6 && (land.isShockLand)) {
        score -= 100;
      }

      // Bonus for dual lands
      if ((land.produces || []).length >= 2) {
        score += 100;
      }

      // Bonus for producing multiple missing colors
      const missingColorCount = (land.produces || []).filter(c => missingColors.has(c)).length;
      score += missingColorCount * 250;

      return { land, score };
    });

    scoredLands.sort((a, b) => b.score - a.score);

    return scoredLands[0].land;
  };

  const doesLandEnterTapped = (land, battlefield, turn, commanderMode) => {
    // Shock lands have special logic - they CAN enter untapped but default to tapped
    if (land.isShockLand) {
      return true; // Default to tapped, we'll pay life to untap it
    }

    // Fast lands: enter untapped if you control 2 or fewer other lands
    if (land.isFast) {
      const landsOnBattlefield = battlefield.filter(p => p.card.isLand).length;
      return landsOnBattlefield > 2; // Tapped if more than 2 other lands
    }

    // Battle Lands / Tango Lands: enter untapped if you control 2+ basic lands
    if (land.isBattleLand) {
      const basicLands = battlefield.filter(p => p.card.isLand && p.card.isBasic).length;
      return basicLands < 2; // Tapped unless 2+ basics
    }

    // Check lands: enter tapped unless you control a land with the appropriate basic type
    if (land.isCheck) {
      // Prefer the explicit checkTypes array stored on the card (from Lands.js);
      // fall back to re-deriving from colour pairs for cards parsed without LAND_DATA.
      let needsTypes = land.checkTypes?.length ? [...land.checkTypes] : [];
      if (needsTypes.length === 0) {
        if (land.produces.includes('W') && land.produces.includes('U')) {
          needsTypes.push('Plains', 'Island');
        } else if (land.produces.includes('U') && land.produces.includes('B')) {
          needsTypes.push('Island', 'Swamp');
        } else if (land.produces.includes('B') && land.produces.includes('R')) {
          needsTypes.push('Swamp', 'Mountain');
        } else if (land.produces.includes('R') && land.produces.includes('G')) {
          needsTypes.push('Mountain', 'Forest');
        } else if (land.produces.includes('G') && land.produces.includes('W')) {
          needsTypes.push('Forest', 'Plains');
        } else if (land.produces.includes('W') && land.produces.includes('B')) {
          needsTypes.push('Plains', 'Swamp');
        } else if (land.produces.includes('U') && land.produces.includes('R')) {
          needsTypes.push('Island', 'Mountain');
        } else if (land.produces.includes('B') && land.produces.includes('G')) {
          needsTypes.push('Swamp', 'Forest');
        } else if (land.produces.includes('R') && land.produces.includes('W')) {
          needsTypes.push('Mountain', 'Plains');
        } else if (land.produces.includes('G') && land.produces.includes('U')) {
          needsTypes.push('Forest', 'Island');
        }
      }

      // Check if battlefield has any land with these types
      const hasAppropriateType = battlefield.some(p => {
        if (!p.card.isLand) return false;
        const subtypes = p.card.landSubtypes || [];
        return needsTypes.some(type => subtypes.includes(type));
      });

      return !hasAppropriateType; // Enters tapped unless we have the right type
    }

    // Starting Town: enters untapped ONLY on turns 1, 2, or 3 (0-indexed: 0, 1, 2)
    if (land.name === 'starting town') {
      return turn > 2; // Tapped after turn 3
    }

    // Crowd / Bond Lands: enter untapped if 2+ opponents (i.e. Commander Mode).
    // Uses the isCrowd flag stored on the card by processLand (from Lands.js sim_flags)
    // rather than re-creating a hardcoded Set here.
    if (land.isCrowd) {
      return !commanderMode; // Tapped if NOT commander mode
    }

    if (land.entersTappedAlways) return true;

    // Check for condition (e.g., "unless you have two or more opponents")
    if (land.hasCondition) return false; // Assume Commander format

    return false;
  };

  const castSpells = (hand, battlefield, graveyard, turnLog, keyCardNames, parsedDeck, library, turn = 999) => {
    let changed = true;

    // Phase 1: Cast mana-producing permanents (creatures, artifacts)
    // Note: Exploration effects are already cast in the main turn loop BEFORE lands
    // Priority: MOX_PRIORITY_ARTIFACTS first, then regular mana dorks, then other artifacts
    while (changed) {
      changed = false;
      const manaAvailable = calculateManaAvailability(battlefield, turn);

      const creatures = hand.filter(c => c.isManaCreature);
      const exploration = hand.filter(c => c.isExploration); // Usually empty - already cast earlier
      // Burst sources are intentionally excluded â€” they stay in hand for the graph.
      const artifacts = hand.filter(c => c.isManaArtifact && !BURST_MANA_SOURCES.has(c.name?.toLowerCase()));

      // Sort: MOX_PRIORITY_ARTIFACTS always first (weight -1), then by CMC ascending
      const castable = [...creatures, ...exploration, ...artifacts].sort((a, b) => {
        const aPrio = MOX_PRIORITY_ARTIFACTS.has(a.name?.toLowerCase()) ? -1 : a.cmc;
        const bPrio = MOX_PRIORITY_ARTIFACTS.has(b.name?.toLowerCase()) ? -1 : b.cmc;
        return aPrio - bPrio;
      });

      for (const spell of castable) {
        if (canPlayCard(spell, manaAvailable)) {
          // Special artifact ETB-cost requirements â€” capture names for the play log
          let etbNote = ''; // filled in below for each cost type

          // discardLand: Mox Diamond â€” discard a land from hand
          if (spell.etbCost === 'discardLand' || spell.isMoxDiamond) {
            const landsInHand = hand.filter(c => c.isLand);
            if (landsInHand.length === 0) {
              continue; // Can't play without a land to discard
            }
            // Prefer tapped/basics so we lose as little tempo as possible
            const landToDiscard = landsInHand.find(l => l.entersTappedAlways) || landsInHand[0];
            etbNote = ` (discarded ${landToDiscard.name})`;
            const discardIndex = hand.indexOf(landToDiscard);
            hand.splice(discardIndex, 1);
            graveyard.push(landToDiscard);
          }

          // imprintNonland: Chrome Mox â€” exile a non-land from hand
          else if (spell.etbCost === 'imprintNonland' || spell.isChromeMox) {
            const nonLandsInHand = hand.filter(c => !c.isLand);
            if (nonLandsInHand.length === 0) {
              continue; // Can't play without a non-land to imprint
            }
            const cardToImprint = nonLandsInHand[0];
            etbNote = ` (imprinted ${cardToImprint.name})`;
            const imprintIndex = hand.indexOf(cardToImprint);
            hand.splice(imprintIndex, 1);
            // Imprinted card is exiled; color production already set to any-color in ARTIFACT_DATA
          }

          // discardHand: Lion's Eye Diamond â€” discard entire hand
          else if (spell.etbCost === 'discardHand') {
            const handNames = hand.filter(c => c !== spell).map(c => c.name);
            if (handNames.length > 0) {
              etbNote = ` (discarded hand: ${handNames.join(', ')})`;
              // Move entire hand (except the LED itself) to graveyard
              const rest = hand.filter(c => c !== spell);
              rest.forEach(c => graveyard.push(c));
              hand.length = 0;
              hand.push(spell); // keep the LED so it can be moved to battlefield below
            } else {
              etbNote = ' (discarded empty hand)';
            }
          }

          // sacrifice: one-shot rocks (Lotus Petal, Jeweled Lotus) â€” noted but no extra cost
          else if (spell.etbCost === 'sacrifice') {
            etbNote = ' (sacrifice for mana)';
          }

          // condition-based restrictions: warn in the log if not yet met
          // Note: SIMPLIFY_MOX_CONDITIONS bypasses these from turn 3 onwards.
          if (spell.condition === 'metalcraft' && !(SIMPLIFY_MOX_CONDITIONS && turn >= 2)) {
            const artifactCount = battlefield.filter(p =>
              p.card.type?.includes('artifact') || p.card.isManaArtifact
            ).length;
            if (artifactCount < 2) etbNote += ' âš  metalcraft not yet active';
          }
          if (spell.condition === 'legendary' && !(SIMPLIFY_MOX_CONDITIONS && turn >= 2)) {
            const hasLegendary = battlefield.some(p =>
              p.card.type?.includes('Legendary') || p.card.oracleText?.includes('Legendary')
            );
            if (!hasLegendary) etbNote += ' âš  no legendary â€” no mana produced';
          }

          const index = hand.indexOf(spell);
          hand.splice(index, 1);

          battlefield.push({
            card: spell,
            tapped: spell.entersTapped || false,
            summoningSick: spell.isManaCreature || spell.isExploration
          });

          // Tap mana sources to pay for the spell
          tapManaSources(spell, battlefield);

          if (turnLog) {
            let type = 'permanent';
            if (spell.isManaArtifact) type = 'artifact';
            else if (spell.isManaCreature) type = 'creature';
            else if (spell.isExploration) type = spell.isCreature ? 'creature' : (spell.isArtifact ? 'artifact' : 'permanent');

            const explorationSuffix = spell.isExploration ? ' (Exploration effect)' : '';
            const tappedSuffix = spell.entersTapped ? ' (enters tapped)' : '';

            turnLog.actions.push(`Cast ${type}: ${spell.name}${explorationSuffix}${tappedSuffix}${etbNote}`);
          }

          changed = true;
          break;
        }
      }
    }

    // Phase 2: Cast ramp spells (sorceries that put lands onto the battlefield)
    if (includeRampSpells) {
      let rampChanged = true;
      while (rampChanged) {
        rampChanged = false;
        const manaAvailable = calculateManaAvailability(battlefield, turn);
        const rampInHand = hand.filter(c => c.isRampSpell && !disabledRampSpells.has(c.name));

        for (const rampSpell of rampInHand.sort((a, b) => a.cmc - b.cmc)) {
          if (!canPlayCard(rampSpell, manaAvailable)) continue;

          // Only cast the spell if there is at least one matching land in the library.
          // Count how many eligible lands exist (need at least 1 for battlefield;
          // spells that also put a land to hand need at least 2).
          const eligibleInLibrary = library.filter(c => matchesRampFilter(c, rampSpell));
          const requiredCount = (rampSpell.landsToAdd || 1) > 0 ? 1 : 0;
          // For spells that need a land to hand too, we want at least 2 eligible
          const minNeeded = requiredCount + (rampSpell.landsToHand > 0 ? 1 : 0);
          if (eligibleInLibrary.length < Math.max(1, minNeeded === 0 ? 1 : minNeeded)) continue;

          // Remove from hand, add to graveyard
          const idx = hand.indexOf(rampSpell);
          hand.splice(idx, 1);
          graveyard.push(rampSpell);

          // Tap mana sources to pay for the spell
          tapManaSources(rampSpell, battlefield);

          // Sacrifice a land if required (Harrow-style)
          // Priority: basic > dual (non-basic, non-fetch, non-bounce) > bounce. Never sacrifice a fetch land.
          let sacrificedLandName = null;
          if (rampSpell.sacrificeLand) {
            const candidates = battlefield.filter(p => p.card.isLand && !p.card.isFetch);
            const basics    = candidates.filter(p => p.card.isBasic);
            const duals     = candidates.filter(p => !p.card.isBasic && !p.card.isBounce);
            const bounces   = candidates.filter(p => p.card.isBounce);
            const toSacrifice = basics[0] ?? duals[0] ?? bounces[0] ?? null;
            if (toSacrifice) {
              sacrificedLandName = toSacrifice.card.name;
              battlefield.splice(battlefield.indexOf(toSacrifice), 1);
              graveyard.push(toSacrifice.card);
            }
          }

          // Find lands in library to put on battlefield (respects fetchFilter; no fallback)
          const landsToFieldNames = [];
          const target = rampSpell.landsToAdd || 1;
          for (let li = 0; li < library.length && landsToFieldNames.length < target; li++) {
            if (matchesRampFilter(library[li], rampSpell)) {
              const [fetchedCard] = library.splice(li, 1);
              li--;
              battlefield.push({ card: fetchedCard, tapped: rampSpell.landsTapped, enteredTapped: rampSpell.landsTapped });
              landsToFieldNames.push(fetchedCard.name);
            }
          }

          // Lands to hand (Cultivate / Kodama's Reach effect)
          const landsToHandNames = [];
          if (rampSpell.landsToHand > 0) {
            for (let li = 0; li < library.length && landsToHandNames.length < rampSpell.landsToHand; li++) {
              if (matchesRampFilter(library[li], rampSpell)) {
                const [card] = library.splice(li, 1);
                li--;
                hand.push(card);
                landsToHandNames.push(card.name);
              }
            }
          }

          if (turnLog) {
            const tappedNote = rampSpell.landsTapped ? 'tapped' : 'untapped';
            const sacNote = sacrificedLandName ? `, sac'd ${sacrificedLandName}` : '';
            const fieldNote = landsToFieldNames.length > 0
              ? ` â†’ ${landsToFieldNames.join(', ')} (${tappedNote})`
              : ' â†’ no land found';
            const handNote = landsToHandNames.length > 0
              ? `; ${landsToHandNames.join(', ')} to hand`
              : '';
            turnLog.actions.push(`Cast ramp spell: ${rampSpell.name}${sacNote}${fieldNote}${handNote}`);
          }

          rampChanged = true;
          break;
        }
      }
    }
  };

  const tapManaSources = (spell, battlefield) => {
    // Parse mana cost
    const symbols = spell.manaCost.match(/\{([^}]+)\}/g) || [];
    const colorNeeds = { W: 0, U: 0, B: 0, R: 0, G: 0 };
    let genericNeeded = 0;
    let totalNeeded = 0;

    symbols.forEach(symbol => {
      const clean = symbol.replace(/[{}]/g, '');
      if (['W', 'U', 'B', 'R', 'G'].includes(clean)) {
        colorNeeds[clean]++;
        totalNeeded++;
      } else if (!isNaN(parseInt(clean))) {
        const num = parseInt(clean);
        genericNeeded += num;
        totalNeeded += num;
      }
    });

    // First, tap sources for colored mana requirements
    ['W', 'U', 'B', 'R', 'G'].forEach(color => {
      let needed = colorNeeds[color];
      if (needed === 0) return;

      const sources = battlefield.filter(p =>
        !p.tapped &&
        p.card.produces &&
        p.card.produces.includes(color) &&
        (!p.summoningSick || p.card.isLand)
      );

      for (const source of sources) {
        if (needed <= 0) break;
        source.tapped = true;
        needed--;
        totalNeeded--;
      }
    });

    // Then tap any remaining sources for generic mana
    const untappedSources = battlefield.filter(p =>
      !p.tapped &&
      (!p.summoningSick || p.card.isLand)
    );

    for (const source of untappedSources) {
      if (totalNeeded <= 0) break;
      source.tapped = true;
      const amount = source.card.manaAmount || 1;
      totalNeeded -= amount;
    }
  };

  const calculateManaAvailability = (battlefield, turn = 999) => {
    const colors = { W: 0, U: 0, B: 0, R: 0, G: 0, C: 0 };
    let total = 0;

    // From which turn does the simplified Mox condition kick in (0-indexed, so turn 2 = turn 3).
    const moxSimpleTurn = 2;

    battlefield.filter(p => !p.tapped).forEach(permanent => {
      const card = permanent.card;

      if (card.isLand) {
        const landManaAmount = card.manaAmount || 1; // Ancient Tomb/City of Traitors produce 2
        total += landManaAmount;
        // Only count colors from lands that can actually produce them
        card.produces.forEach(color => {
          colors[color] = (colors[color] || 0) + landManaAmount;
        });
      } else if (card.isManaArtifact) {
        // Mox Opal: only produces mana with metalcraft (3+ artifacts).
        // SIMPLIFY_MOX_CONDITIONS (flag) â€“ skip this restriction from turn 3 onwards.
        if (card.isMoxOpal) {
          if (!(SIMPLIFY_MOX_CONDITIONS && turn >= moxSimpleTurn)) {
            const artifactCount = battlefield.filter(p =>
              p.card.type?.includes('artifact') || p.card.isManaArtifact
            ).length;
            if (artifactCount < 3) {
              return; // Mox Opal doesn't produce mana without metalcraft
            }
          }
        }

        // Mox Amber: only produces colors from legendary creatures/planeswalkers.
        // SIMPLIFY_MOX_CONDITIONS (flag) â€“ skip this restriction from turn 3 onwards.
        if (card.isMoxAmber) {
          if (!(SIMPLIFY_MOX_CONDITIONS && turn >= moxSimpleTurn)) {
            const legendaries = battlefield.filter(p =>
              p.card.oracleText?.includes('Legendary') ||
              p.card.type?.includes('Legendary')
            );
            if (legendaries.length === 0) {
              return; // Mox Amber doesn't produce mana without legendaries
            }
          }
          // Proper implementation would track legendary colors; simplified: any color
        }

        // Artifacts don't have summoning sickness - can tap immediately
        total += card.manaAmount || 1;
        card.produces.forEach(color => {
          colors[color] = (colors[color] || 0) + (card.manaAmount || 1);
        });
      } else if (card.isManaCreature && !permanent.summoningSick) {
        // Creatures have summoning sickness - can't tap until next turn
        total += card.manaAmount || 1;
        card.produces.forEach(color => {
          colors[color] = (colors[color] || 0) + (card.manaAmount || 1);
        });
      }
    });

    return { total, colors };
  };

  const canPlayCard = (card, manaAvailable) => {
    if (card.cmc > manaAvailable.total) return false;

    // Parse color requirements from mana cost
    const colorRequirements = { W: 0, U: 0, B: 0, R: 0, G: 0 };
    const symbols = card.manaCost.match(/\{([^}]+)\}/g) || [];

    symbols.forEach(symbol => {
      const clean = symbol.replace(/[{}]/g, '');
      // Only count actual color symbols (not numbers or X)
      if (['W', 'U', 'B', 'R', 'G'].includes(clean)) {
        colorRequirements[clean]++;
      }
    });

    // Check if we have enough of each color
    for (const color in colorRequirements) {
      const required = colorRequirements[color];
      if (required > 0) {
        const available = manaAvailable.colors[color] || 0;
        if (available < required) {
          return false;
        }
      }
    }

    return true;
  };

  const average = (arr) => {
    if (!arr || arr.length === 0) return 0;
    const sum = arr.reduce((sum, val) => {
      // Skip undefined, null, NaN values
      if (val === undefined || val === null || isNaN(val)) return sum;
      return sum + val;
    }, 0);
    return arr.length > 0 ? sum / arr.length : 0;
  };

  // Safe toFixed - handles undefined/NaN/null
  const safeToFixed = (value, decimals = 2) => {
    if (value === undefined || value === null || isNaN(value)) return 0;
    return parseFloat(value.toFixed(decimals));
  };

  // Export functions
  const exportResultsAsPNG = async (event) => {
    if (!simulationResults) return;

    try {
      // Load html2canvas library
      const html2canvas = await loadHtml2Canvas();

      // Get the results section
      const resultsSection = document.getElementById('results-section');
      if (!resultsSection) {
        alert('Results section not found');
        return;
      }

      // Show loading state
      const button = event.target;
      const originalButtonText = button.textContent;
      button.textContent = 'ðŸ“¸ Capturing...';
      button.disabled = true;

      // Wait a bit for any animations to finish
      await new Promise(resolve => setTimeout(resolve, 500));

      // Capture the element
      const canvas = await html2canvas(resultsSection, {
        backgroundColor: '#f9fafb',
        scale: 2, // Higher quality
        logging: false,
        useCORS: true
      });

      // Convert to blob and download
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `mtg-simulation-results-${Date.now()}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        // Restore button
        button.textContent = originalButtonText;
        button.disabled = false;
      });
    } catch (err) {
      console.error('Export error:', err);
      alert('Failed to export. Please use your browser screenshot tool (Ctrl+Shift+S on Windows, Cmd+Shift+5 on Mac)');
      if (event && event.target) {
        event.target.disabled = false;
      }
    }
  };

  const downloadTextFile = (content, filename) => {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  };

  // Mana symbol helper
  const getManaSymbol = (color) => {
    const symbols = {
      W: 'â˜€ï¸',
      U: 'ðŸ’§',
      B: 'ðŸ’€',
      R: 'ðŸ”¥',
      G: 'ðŸŒ¿',
      C: 'â—‡'
    };
    return symbols[color] || '';
  };

  const parseManaSymbols = (manaCost) => {
    if (!manaCost) return [];
    const symbols = manaCost.match(/\{([^}]+)\}/g) || [];
    return symbols.map(s => s.replace(/[{}]/g, ''));
  };

  const renderManaCost = (manaCost) => {
    const symbols = parseManaSymbols(manaCost);
    return symbols.map((symbol, idx) => {
      const colorSymbols = { W: 'â˜€ï¸', U: 'ðŸ’§', B: 'ðŸ’€', R: 'ðŸ”¥', G: 'ðŸŒ¿', C: 'â—‡' };
      if (colorSymbols[symbol]) {
        return <span key={idx} style={{ marginLeft: '2px' }}>{colorSymbols[symbol]}</span>;
      }
      // Generic mana (numbers)
      return <span key={idx} style={{
        marginLeft: '2px',
        display: 'inline-block',
        width: '18px',
        height: '18px',
        borderRadius: '50%',
        background: '#d1d5db',
        fontSize: '0.7rem',
        textAlign: 'center',
        lineHeight: '18px',
        fontWeight: 600
      }}>{symbol}</span>;
    });
  };

  const getFetchSymbol = (fetchType) => {
    const symbols = {
      classic: 'âš¡',
      slow: 'ðŸŒ',
      mana_cost: 'ðŸ’°',
      free_slow: 'ðŸ†“'
    };
    return symbols[fetchType] || '';
  };

  // Reusable sequence body: opening hand + turn-by-turn actions.
  // accentColor drives the left-border on each turn block.
  const renderSequenceBody = (data, accentColor = '#667eea') => (
    <>
      <div style={{ marginBottom: '12px', padding: '10px', background: 'white', borderRadius: '6px' }}>
        <p style={{ fontWeight: 600, margin: '0 0 6px 0', fontSize: '0.85rem', color: '#374151' }}>
          Opening Hand:
        </p>
        <div style={{ fontSize: '0.8rem', color: '#6b7280' }}>
          {data.openingHand.join(', ')}
        </div>
      </div>
      <div>
        <p style={{ fontWeight: 600, marginBottom: '8px', fontSize: '0.9rem' }}>Turn-by-turn sequence:</p>
        {data.sequence && data.sequence.map((turnLog, idx) => (
          <div key={idx} style={{ marginBottom: '8px', paddingLeft: '10px', borderLeft: `3px solid ${accentColor}` }}>
            <p style={{ margin: '0 0 4px 0', fontWeight: 600, fontSize: '0.85rem', color: '#374151' }}>
              Turn {turnLog.turn}:
            </p>
            {turnLog.actions.length > 0 ? (
              <ul style={{ margin: '0', paddingLeft: '20px', fontSize: '0.8rem', color: '#6b7280' }}>
                {turnLog.actions.map((action, actionIdx) => (
                  <li key={actionIdx}>{action}</li>
                ))}
              </ul>
            ) : (
              <p style={{ margin: 0, fontSize: '0.8rem', color: '#9ca3af', fontStyle: 'italic' }}>No actions</p>
            )}
            {turnLog.lifeLoss > 0 && (
              <p style={{ margin: '4px 0 0 0', fontSize: '0.75rem', color: '#dc2626' }}>
                Life lost this turn: {turnLog.lifeLoss}
              </p>
            )}
          </div>
        ))}
      </div>
    </>
  );

  // Chart data preparation
  const prepareChartData = () => {
    if (!simulationResults) return null;

    const landsData = [];
    const manaByColorData = [];
    const lifeLossData = [];
    const keyCardsData = [];

    for (let i = 0; i < turns; i++) {
      landsData.push({
        turn: i + 1,
        'Total Lands': safeToFixed(simulationResults.landsPerTurn?.[i], 2),
        'Untapped Lands': safeToFixed(simulationResults.untappedLandsPerTurn?.[i], 2)
      });

      manaByColorData.push({
        turn: i + 1,
        'Total Mana': safeToFixed(simulationResults.totalManaPerTurn?.[i], 2),
        'W': safeToFixed(simulationResults.colorsByTurn?.[i]?.W, 2),
        'U': safeToFixed(simulationResults.colorsByTurn?.[i]?.U, 2),
        'B': safeToFixed(simulationResults.colorsByTurn?.[i]?.B, 2),
        'R': safeToFixed(simulationResults.colorsByTurn?.[i]?.R, 2),
        'G': safeToFixed(simulationResults.colorsByTurn?.[i]?.G, 2)
      });

      lifeLossData.push({
        turn: i + 1,
        'Life Loss': safeToFixed(simulationResults.lifeLossPerTurn?.[i], 2)
      });

      const keyCardRow = { turn: i + 1 };
      if (simulationResults.keyCardPlayability) {
        Object.keys(simulationResults.keyCardPlayability).forEach(cardName => {
          keyCardRow[cardName] = safeToFixed(simulationResults.keyCardPlayability[cardName]?.[i], 1);
        });
      }
      // Burst line â€“ only populated if burst cards are in the deck
      if (simulationResults.hasBurstCards && simulationResults.keyCardPlayabilityBurst) {
        Object.keys(simulationResults.keyCardPlayabilityBurst).forEach(cardName => {
          keyCardRow[`${cardName} (+burst)`] = safeToFixed(
            simulationResults.keyCardPlayabilityBurst[cardName]?.[i], 1
          );
        });
      }
      keyCardsData.push(keyCardRow);
    }

    return { landsData, manaByColorData, lifeLossData, keyCardsData };
  };

  const chartData = prepareChartData();

  // Prepare chart data for deck 2 if in comparison mode


  return (
    <div style={{
      fontFamily: "'Inter', 'Segoe UI', sans-serif",
      maxWidth: '1400px',
      margin: '0 auto',
      padding: '20px',
      backgroundColor: '#f9fafb'
    }}>
      {/* Header */}
      <div style={{
        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        color: 'white',
        padding: '30px',
        borderRadius: '12px',
        marginBottom: '20px',
        textAlign: 'center'
      }}>
        <h1 style={{ margin: 0, fontSize: '2rem' }}>ðŸŽ² MTG Monte Carlo Deck Analyzer</h1>
        <p style={{ margin: '10px 0 0', opacity: 0.9 }}>Simulation-based deck analysis for Magic: The Gathering</p>
      </div>

      {/* API Mode Toggle */}
      <div style={{
        background: 'white',
        padding: '20px',
        borderRadius: '12px',
        marginBottom: '20px',
        boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
      }}>
        <h3 style={{ marginTop: 0 }}>âš™ï¸ Data Source</h3>
        <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
          <label style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
            <input
              type="radio"
              checked={apiMode === 'local'}
              onChange={() => setApiMode('local')}
            />
            Local JSON File
          </label>
          <label style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
            <input
              type="radio"
              checked={apiMode === 'scryfall'}
              onChange={() => setApiMode('scryfall')}
            />
            Scryfall API (Fallback)
          </label>
        </div>

        {apiMode === 'local' && (
          <div style={{ marginTop: '15px' }}>
            <div style={{
              background: '#dbeafe',
              padding: '12px',
              borderRadius: '8px',
              marginBottom: '12px',
              fontSize: '0.875rem'
            }}>
              <p style={{ margin: '0 0 8px 0', fontWeight: 600 }}>ðŸ“¥ How to get cards.json:</p>
              <ol style={{ margin: 0, paddingLeft: '20px' }}>
                <li>Visit <a
                  href="https://scryfall.com/docs/api/bulk-data"
                  target="_blank"
                  rel="noopener noreferrer"
                  style={{ color: '#667eea', fontWeight: 600 }}
                >
                  Scryfall Bulk Data
                </a></li>
                <li>Download <strong>"Default Cards"</strong> (not "All Cards" or "Oracle Cards")</li>
                <li>File size should be ~200-300 MB (compressed)</li>
                <li>Upload the JSON file below</li>
              </ol>
            </div>
            <input
              type="file"
              accept=".json"
              onChange={handleFileUpload}
              style={{ display: 'block' }}
            />
            {cardsDatabase && (
              <p style={{ color: '#22c55e', marginTop: '10px', fontSize: '0.875rem' }}>
                âœ“ Loaded {cardsDatabase.length.toLocaleString()} cards
              </p>
            )}
          </div>
        )}
      </div>

      {/* Deck Input */}
      <div style={{
        background: 'white',
        padding: '20px',
        borderRadius: '12px',
        marginBottom: '20px',
        boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
      }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
          <h3 style={{ margin: 0 }}>ðŸ“ Deck List</h3>
        </div>

        <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '20px' }}>
          <div>
            <div style={{ fontSize: '0.875rem', fontWeight: 600, marginBottom: '8px', color: '#667eea' }}>
              Deck
            </div>
            <textarea
              value={deckText}
              onChange={(e) => setDeckText(e.target.value)}
              placeholder="Paste your deck list here (MTG Arena format)&#10;Example:&#10;4 Lightning Bolt&#10;4 Island&#10;3 Counterspell"
              style={{
                width: '100%',
                height: '200px',
                padding: '10px',
                borderRadius: '8px',
                border: '1px solid #e5e7eb',
                fontSize: '0.875rem',
                fontFamily: 'monospace',
                resize: 'vertical'
              }}
            />
          </div>
        </div>
        <button
          onClick={handleParseDeck}
          style={{
            marginTop: '10px',
            background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            color: 'white',
            padding: '12px 24px',
            borderRadius: '8px',
            border: 'none',
            fontWeight: 600,
            cursor: 'pointer'
          }}
        >
          Parse Deck
        </button>
      </div>

      {/* Error Display */}
      {error && (
        <div style={{
          background: '#fee2e2',
          color: '#dc2626',
          padding: '15px',
          borderRadius: '8px',
          marginBottom: '20px',
          fontSize: '0.875rem'
        }}>
          âš ï¸ {error}
        </div>
      )}

      {/* Parsed Deck Display */}
      {parsedDeck && (
        <div>
          {/* Headers */}

          {/* Deck Statistics Row */}
          <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '20px', marginBottom: '20px', alignItems: 'start' }}>
            <div style={{
              background: 'white',
              padding: '20px',
              borderRadius: '12px',
              boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
            }}>
              <h3 style={{ marginTop: 0 }}>ðŸ“Š Deck Statistics</h3>
              <p>Total Cards: {parsedDeck.totalCards}</p>
              <p>Lands: {parsedDeck.landCount} ({parsedDeck.totalCards > 0 ? ((parsedDeck.landCount / parsedDeck.totalCards) * 100).toFixed(1) : 0}%)</p>
            </div>

          </div>

          {/* Lands Section Row */}
          <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '20px', marginBottom: '20px', alignItems: 'start' }}>
            <div style={{
              background: 'white',
              padding: '20px',
              borderRadius: '12px',
              boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
            }}>
              <h3 style={{ marginTop: 0 }}>ðŸžï¸ Detected Lands ({parsedDeck.landCount})</h3>
              {parsedDeck.lands.map((land, idx) => {
                // Use the hasInternalLogic flag set during parsing
                // This is set to true if the land is in any special set with hardcoded logic
                const showLogic = land.hasInternalLogic;

                return (
                  <div key={idx} style={{
                    padding: '8px 0',
                    borderBottom: '1px solid #f3f4f6',
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                  }}>
                    <div style={{ display: 'flex', alignItems: 'center', flex: 1 }}>
                      <span style={{ fontWeight: 600 }}>{land.quantity}x {land.name}</span>
                      {land.isBasic && <span style={{ marginLeft: '8px', fontSize: '0.875rem' }}>â­</span>}
                      {land.isFetch && <span style={{ marginLeft: '10px', fontSize: '0.875rem' }}>FETCH {getFetchSymbol(land.fetchType)}</span>}
                      {showLogic && (
                        <span style={{
                          marginLeft: '10px',
                          fontSize: '0.75rem',
                          background: '#dbeafe',
                          color: '#1e40af',
                          padding: '2px 6px',
                          borderRadius: '4px',
                          fontWeight: 600
                        }}>
                          LOGIC
                        </span>
                      )}
                      {!showLogic && (
                        <span style={{
                          marginLeft: '10px',
                          fontSize: '0.75rem',
                          background: '#f3f4f6',
                          color: '#6b7280',
                          padding: '2px 6px',
                          borderRadius: '4px'
                        }}>
                          PARSED
                        </span>
                      )}
                    </div>
                    <div style={{ display: 'flex', alignItems: 'center', marginLeft: '10px' }}>
                      {land.produces.map(color => (
                        <span key={color} style={{ marginLeft: '5px', fontSize: '1.2rem' }}>{getManaSymbol(color)}</span>
                      ))}
                    </div>
                  </div>
                );
              })}
            </div>

          </div>

          {/* Mana Artifacts Section Row */}
          {(parsedDeck.artifacts.length > 0) && (
            <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '20px', marginBottom: '20px', alignItems: 'start' }}>
              {parsedDeck.artifacts.length > 0 && (
                <div style={{
                  background: 'white',
                  padding: '20px',
                  borderRadius: '12px',
                  marginBottom: '20px',
                  boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
                }}>
                  <h3 style={{ marginTop: 0 }}>âš™ï¸ Mana Artifacts</h3>
                  <label style={{ display: 'block', marginBottom: '15px' }}>
                    <input
                      type="checkbox"
                      checked={includeArtifacts}
                      onChange={(e) => {
                        setIncludeArtifacts(e.target.checked);
                        if (e.target.checked) {
                          setDisabledArtifacts(new Set());
                        } else {
                          const allArtifacts = new Set(parsedDeck.artifacts.map(a => a.name));
                          setDisabledArtifacts(allArtifacts);
                        }
                      }}
                    />
                    <span style={{ marginLeft: '8px' }}>Enable All Artifacts</span>
                  </label>
                  {parsedDeck.artifacts.map((artifact, idx) => (
                    <div key={idx} style={{
                      padding: '8px 0',
                      borderBottom: '1px solid #f3f4f6',
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center'
                    }}>
                      <label style={{ display: 'flex', alignItems: 'center', flex: 1 }}>
                        <input
                          type="checkbox"
                          checked={includeArtifacts && !disabledArtifacts.has(artifact.name)}
                          onChange={(e) => {
                            const newSet = new Set(disabledArtifacts);
                            if (e.target.checked) {
                              newSet.delete(artifact.name);
                            } else {
                              newSet.add(artifact.name);
                            }
                            setDisabledArtifacts(newSet);
                          }}
                        />
                        <span style={{ marginLeft: '8px', fontWeight: 600 }}>
                          {artifact.quantity}x {artifact.name}
                        </span>
                        <span style={{ marginLeft: '10px', fontSize: '0.875rem', color: '#6b7280' }}>
                          +{artifact.manaAmount} Mana, CMC {artifact.cmc}
                        </span>
                      </label>
                      <div style={{ display: 'flex', alignItems: 'center', marginLeft: '10px' }}>
                        {artifact.produces.map(color => (
                          <span key={color} style={{ marginLeft: '5px', fontSize: '1.2rem' }}>{getManaSymbol(color)}</span>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              )}

            </div>
          )}

          {/* Mana Creatures Section Row */}
          {(parsedDeck.creatures.length > 0) && (
            <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '20px', marginBottom: '20px', alignItems: 'start' }}>
              {parsedDeck.creatures.length > 0 && (
                <div style={{
                  background: 'white',
                  padding: '20px',
                  borderRadius: '12px',
                  boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
                }}>
                  <h3 style={{ marginTop: 0 }}>ðŸŒ± Mana Creatures</h3>
                  <label style={{ display: 'block', marginBottom: '15px' }}>
                    <input
                      type="checkbox"
                      checked={includeCreatures}
                      onChange={(e) => {
                        setIncludeCreatures(e.target.checked);
                        if (e.target.checked) {
                          setDisabledCreatures(new Set());
                        } else {
                          const allCreatures = new Set(parsedDeck.creatures.map(c => c.name));
                          setDisabledCreatures(allCreatures);
                        }
                      }}
                    />
                    <span style={{ marginLeft: '8px' }}>Enable All Creatures</span>
                  </label>
                  {parsedDeck.creatures.map((creature, idx) => (
                    <div key={idx} style={{
                      padding: '8px 0',
                      borderBottom: '1px solid #f3f4f6',
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center'
                    }}>
                      <label style={{ display: 'flex', alignItems: 'center', flex: 1 }}>
                        <input
                          type="checkbox"
                          checked={includeCreatures && !disabledCreatures.has(creature.name)}
                          onChange={(e) => {
                            const newSet = new Set(disabledCreatures);
                            if (e.target.checked) {
                              newSet.delete(creature.name);
                            } else {
                              newSet.add(creature.name);
                            }
                            setDisabledCreatures(newSet);
                          }}
                        />
                        <span style={{ marginLeft: '8px', fontWeight: 600 }}>
                          {creature.quantity}x {creature.name}
                        </span>
                        <span style={{ marginLeft: '10px', fontSize: '0.875rem', color: '#6b7280' }}>
                          +{creature.manaAmount} Mana, CMC {creature.cmc}
                        </span>
                      </label>
                      <div style={{ display: 'flex', alignItems: 'center', marginLeft: '10px' }}>
                        {creature.produces.map(color => (
                          <span key={color} style={{ marginLeft: '5px', fontSize: '1.2rem' }}>{getManaSymbol(color)}</span>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              )}

            </div>
          )}

          {/* Exploration Effects Section Row */}
          {(parsedDeck.exploration && parsedDeck.exploration.length > 0) && (
            <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '20px', marginBottom: '20px', alignItems: 'start' }}>
              {parsedDeck.exploration && parsedDeck.exploration.length > 0 && (
                <div style={{
                  background: 'white',
                  padding: '20px',
                  borderRadius: '12px',
                  boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
                }}>
                  <h3 style={{ marginTop: 0 }}>ðŸŒ³ Exploration Effects</h3>
                  <label style={{ display: 'block', marginBottom: '15px' }}>
                    <input
                      type="checkbox"
                      checked={includeExploration}
                      onChange={(e) => {
                        setIncludeExploration(e.target.checked);
                        if (e.target.checked) {
                          setDisabledExploration(new Set());
                        } else {
                          const allExploration = new Set(parsedDeck.exploration.map(c => c.name));
                          setDisabledExploration(allExploration);
                        }
                      }}
                    />
                    <span style={{ marginLeft: '8px' }}>Enable All Exploration Effects</span>
                  </label>
                  {parsedDeck.exploration.map((exploration, idx) => (
                    <div key={idx} style={{ padding: '8px 0', borderBottom: '1px solid #f3f4f6' }}>
                      <label>
                        <input
                          type="checkbox"
                          checked={includeExploration && !disabledExploration.has(exploration.name)}
                          onChange={(e) => {
                            const newSet = new Set(disabledExploration);
                            if (e.target.checked) {
                              newSet.delete(exploration.name);
                            } else {
                              newSet.add(exploration.name);
                            }
                            setDisabledExploration(newSet);
                          }}
                        />
                        <span style={{ marginLeft: '8px', fontWeight: 600 }}>
                          {exploration.quantity}x {exploration.name}
                        </span>
                        <span style={{ marginLeft: '10px', fontSize: '0.875rem', color: '#6b7280' }}>
                          {exploration.landsPerTurn} Lands/Turn, CMC {exploration.cmc}
                        </span>
                      </label>
                    </div>
                  ))}
                </div>
              )}

            </div>
          )}

          {/* Ramp Spells Section Row */}
          {(parsedDeck.rampSpells && parsedDeck.rampSpells.length > 0) && (
            <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '20px', marginBottom: '20px', alignItems: 'start' }}>
              <div style={{
                background: 'white',
                padding: '20px',
                borderRadius: '12px',
                boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
              }}>
                <h3 style={{ marginTop: 0 }}>ðŸŒ¿ Ramp Spells</h3>
                <label style={{ display: 'block', marginBottom: '15px' }}>
                  <input
                    type="checkbox"
                    checked={includeRampSpells}
                    onChange={(e) => {
                      setIncludeRampSpells(e.target.checked);
                      if (e.target.checked) {
                        setDisabledRampSpells(new Set());
                      } else {
                        const allRamp = new Set(parsedDeck.rampSpells.map(c => c.name));
                        setDisabledRampSpells(allRamp);
                      }
                    }}
                  />
                  <span style={{ marginLeft: '8px' }}>Enable All Ramp Spells</span>
                </label>
                {parsedDeck.rampSpells.map((ramp, idx) => (
                  <div key={idx} style={{
                    padding: '8px 0',
                    borderBottom: '1px solid #f3f4f6',
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                  }}>
                    <label style={{ display: 'flex', alignItems: 'center', flex: 1 }}>
                      <input
                        type="checkbox"
                        checked={includeRampSpells && !disabledRampSpells.has(ramp.name)}
                        onChange={(e) => {
                          const newSet = new Set(disabledRampSpells);
                          if (e.target.checked) {
                            newSet.delete(ramp.name);
                          } else {
                            newSet.add(ramp.name);
                          }
                          setDisabledRampSpells(newSet);
                        }}
                      />
                      <span style={{ marginLeft: '8px', fontWeight: 600 }}>
                        {ramp.quantity}x {ramp.name}
                      </span>
                      <span style={{ marginLeft: '10px', fontSize: '0.875rem', color: '#6b7280' }}>
                        +{ramp.landsToAdd} land{ramp.landsToAdd !== 1 ? 's' : ''}{ramp.landsTapped ? ' (tapped)' : ' (untapped)'}
                        {ramp.fetchFilter === 'basic' ? ' Â· basics only' : ''}
                        {ramp.fetchFilter === 'subtype' && ramp.fetchSubtypes ? ` Â· ${ramp.fetchSubtypes.join('/')} type` : ''}
                        {ramp.fetchFilter === 'snow' ? ' Â· snow lands' : ''}
                        {ramp.fetchFilter === 'any' ? ' Â· any land' : ''}
                        {ramp.sacrificeLand ? ' Â· sac a land' : ''}
                        {ramp.landsToHand > 0 ? ` Â· +${ramp.landsToHand} to hand` : ''}
                        {' Â· CMC '}{ramp.cmc}
                      </span>
                    </label>
                    <div style={{ marginLeft: '10px', fontSize: '1.2rem' }}>
                      {renderManaCost(ramp.manaCost)}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Rituals Section */}
          {(parsedDeck.rituals && parsedDeck.rituals.length > 0) && (
            <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '20px', marginBottom: '20px', alignItems: 'start' }}>
              <div style={{
                background: 'white',
                padding: '20px',
                borderRadius: '12px',
                boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
              }}>
                <h3 style={{ marginTop: 0 }}>âš¡ Ritual Spells (Burst Mana)</h3>
                <p style={{ fontSize: '0.875rem', color: '#6b7280', marginBottom: '12px' }}>
                  Rituals contribute their net mana gain to the &ldquo;with burst&rdquo; key-card line.
                </p>
                <label style={{ display: 'block', marginBottom: '15px' }}>
                  <input
                    type="checkbox"
                    checked={includeRituals}
                    onChange={(e) => {
                      setIncludeRituals(e.target.checked);
                      if (e.target.checked) {
                        setDisabledRituals(new Set());
                      } else {
                        const allRituals = new Set(parsedDeck.rituals.map(c => c.name));
                        setDisabledRituals(allRituals);
                      }
                    }}
                  />
                  <span style={{ marginLeft: '8px' }}>Enable All Rituals</span>
                </label>
                {parsedDeck.rituals.map((ritual, idx) => (
                  <div key={idx} style={{
                    padding: '8px 0',
                    borderBottom: '1px solid #f3f4f6',
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                  }}>
                    <label style={{ display: 'flex', alignItems: 'center', flex: 1 }}>
                      <input
                        type="checkbox"
                        checked={includeRituals && !disabledRituals.has(ritual.name)}
                        onChange={(e) => {
                          const newSet = new Set(disabledRituals);
                          if (e.target.checked) {
                            newSet.delete(ritual.name);
                          } else {
                            newSet.add(ritual.name);
                          }
                          setDisabledRituals(newSet);
                        }}
                      />
                      <span style={{ marginLeft: '8px', fontWeight: 600 }}>
                        {ritual.quantity}x {ritual.name}
                      </span>
                      <span style={{ marginLeft: '10px', fontSize: '0.875rem', color: '#6b7280' }}>
                        +{ritual.manaProduced} mana produced&nbsp;&nbsp;
                        {ritual.netGain > 0 ? `(+${ritual.netGain} net)` : ritual.netGain === 0 ? '(neutral)' : `(${ritual.netGain} net)`}
                        {' Â· CMC '}{ritual.cmc}
                      </span>
                    </label>
                    <div style={{ marginLeft: '10px', fontSize: '1.2rem' }}>
                      {renderManaCost(ritual.manaCost)}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Spells & Key Cards Section */}
          {(parsedDeck.spells.length > 0 || parsedDeck.creatures.length > 0 || parsedDeck.artifacts.length > 0 || (parsedDeck.rituals && parsedDeck.rituals.length > 0) || (parsedDeck.rampSpells && parsedDeck.rampSpells.length > 0) || (parsedDeck.exploration && parsedDeck.exploration.length > 0)) && (
            <div style={{
              background: 'white',
              padding: '20px',
              borderRadius: '12px',
              marginBottom: '20px',
              boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
            }}>
              <h3 style={{ marginTop: 0 }}>ðŸŽ´ Spells & Creatures (Key Card Selection)</h3>
              <p style={{ fontSize: '0.875rem', color: '#6b7280' }}>Select cards to track playability:</p>
              {[...parsedDeck.spells, ...parsedDeck.creatures, ...parsedDeck.artifacts, ...(parsedDeck.rituals || []), ...(parsedDeck.rampSpells || []), ...(parsedDeck.exploration || [])]
                .sort((a, b) => a.cmc - b.cmc)
                .map((card, idx) => (
                  <div
                    key={idx}
                    style={{
                      padding: '8px',
                      borderBottom: '1px solid #f3f4f6',
                      cursor: 'pointer',
                      background: selectedKeyCards.has(card.name) ? '#dbeafe' : 'transparent',
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center'
                    }}
                    onClick={() => {
                      const newSet = new Set(selectedKeyCards);
                      if (newSet.has(card.name)) {
                        newSet.delete(card.name);
                      } else {
                        newSet.add(card.name);
                      }
                      setSelectedKeyCards(newSet);
                    }}
                  >
                    <div style={{ display: 'flex', alignItems: 'center', flex: 1 }}>
                      <input
                        type="checkbox"
                        checked={selectedKeyCards.has(card.name)}
                        readOnly
                      />
                      <span style={{ marginLeft: '8px', fontWeight: 600 }}>
                        {card.quantity}x {card.name}
                      </span>
                      <span style={{ marginLeft: '10px', fontSize: '0.875rem', color: '#6b7280' }}>
                        CMC {card.cmc}
                      </span>
                    </div>
                    <div style={{ marginLeft: '10px', fontSize: '1.2rem' }}>
                      {renderManaCost(card.manaCost)}
                    </div>
                  </div>
                ))}
            </div>
          )}

          {/* Simulation Settings */}
          <div style={{
            background: 'white',
            padding: '20px',
            borderRadius: '12px',
            marginBottom: '20px',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
          }}>
            <h3 style={{ marginTop: 0 }}>âš™ï¸ Simulation Settings</h3>

            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '15px' }}>
              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontSize: '0.875rem', fontWeight: 600 }}>
                  Number of Simulations
                </label>
                <input
                  type="number"
                  value={iterations}
                  onChange={(e) => setIterations(parseInt(e.target.value))}
                  min="1000"
                  max="100000"
                  style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid #e5e7eb' }}
                />
              </div>

              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontSize: '0.875rem', fontWeight: 600 }}>
                  Turns to Simulate
                </label>
                <input
                  type="number"
                  value={turns}
                  onChange={(e) => setTurns(parseInt(e.target.value))}
                  min="1"
                  max="15"
                  style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid #e5e7eb' }}
                />
              </div>

              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontSize: '0.875rem', fontWeight: 600 }}>
                  Starting Hand Size
                </label>
                <input
                  type="number"
                  value={handSize}
                  onChange={(e) => setHandSize(parseInt(e.target.value))}
                  min="1"
                  max="10"
                  style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid #e5e7eb' }}
                />
              </div>

              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontSize: '0.875rem', fontWeight: 600 }}>
                  Turn to View Play Sequences
                </label>
                <input
                  type="range"
                  value={selectedTurnForSequences}
                  onChange={(e) => setSelectedTurnForSequences(parseInt(e.target.value))}
                  min="1"
                  max={turns}
                  style={{ width: '100%' }}
                />
                <div style={{ textAlign: 'center', fontSize: '0.875rem', marginTop: '5px' }}>Turn {selectedTurnForSequences}</div>
              </div>

              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontSize: '0.875rem', fontWeight: 600 }}>
                  Number of Example Sequences
                </label>
                <input
                  type="range"
                  value={maxSequences}
                  onChange={(e) => setMaxSequences(parseInt(e.target.value))}
                  min="1"
                  max="10"
                  style={{ width: '100%' }}
                />
                <div style={{ textAlign: 'center', fontSize: '0.875rem', marginTop: '5px' }}>{maxSequences} {maxSequences === 1 ? 'example' : 'examples'}</div>
              </div>
            </div>

            <div style={{ marginTop: '15px', padding: '15px', background: '#f3f4f6', borderRadius: '8px' }}>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={commanderMode}
                  onChange={(e) => setCommanderMode(e.target.checked)}
                  style={{ marginRight: '8px', cursor: 'pointer' }}
                />
                <span style={{ fontSize: '0.875rem', fontWeight: 600 }}>
                  ðŸŽ© Commander Mode (100-card singleton, optimized for multiplayer)
                </span>
              </label>
              {commanderMode && (
                <div style={{ marginTop: '8px', fontSize: '0.75rem', color: '#6b7280', paddingLeft: '24px' }}>
                  Assumes multiplayer environment: Crowd lands enter untapped, longer game simulation recommended
                </div>
              )}
            </div>

            <div style={{ marginTop: '15px', padding: '15px', background: '#f9fafb', borderRadius: '8px' }}>
              <label style={{ display: 'flex', alignItems: 'center', marginBottom: '10px' }}>
                <input
                  type="checkbox"
                  checked={enableMulligans}
                  onChange={(e) => setEnableMulligans(e.target.checked)}
                />
                <span style={{ marginLeft: '8px', fontWeight: 600 }}>Enable Mulligan Logic</span>
              </label>

              {enableMulligans && (
                <div style={{ marginTop: '15px', paddingLeft: '10px', borderLeft: '3px solid #667eea' }}>
                  <div style={{ marginBottom: '15px' }}>
                    <label style={{ display: 'block', marginBottom: '8px', fontSize: '0.875rem', fontWeight: 600 }}>
                      Mulligan Rule
                    </label>
                    <select
                      value={mulliganRule}
                      onChange={(e) => setMulliganRule(e.target.value)}
                      style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid #e5e7eb' }}
                    >
                      <option value="london">London Mulligan (draw 7, bottom N cards)</option>
                      <option value="vancouver">Vancouver Mulligan (draw N-1 cards)</option>
                    </select>
                  </div>

                  <div style={{ marginBottom: '15px' }}>
                    <label style={{ display: 'block', marginBottom: '8px', fontSize: '0.875rem', fontWeight: 600 }}>
                      Mulligan Strategy
                    </label>
                    <select
                      value={mulliganStrategy}
                      onChange={(e) => setMulliganStrategy(e.target.value)}
                      style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid #e5e7eb' }}
                    >
                      <option value="conservative">Conservative (only 0 or 7 lands)</option>
                      <option value="balanced">Balanced (0/7 lands, no early plays)</option>
                      <option value="aggressive">Aggressive (2-4 lands only)</option>
                      <option value="custom">Custom Rules</option>
                    </select>
                  </div>

                  {mulliganStrategy === 'custom' && (
                    <div style={{ marginTop: '10px', padding: '10px', background: 'white', borderRadius: '6px' }}>
                      <div style={{ fontSize: '0.875rem', fontWeight: 600, marginBottom: '10px' }}>Custom Mulligan Rules:</div>

                      <label style={{ display: 'block', marginBottom: '8px' }}>
                        <input
                          type="checkbox"
                          checked={customMulliganRules.mulligan0Lands}
                          onChange={(e) => setCustomMulliganRules({ ...customMulliganRules, mulligan0Lands: e.target.checked })}
                        />
                        <span style={{ marginLeft: '8px', fontSize: '0.875rem' }}>Mulligan if 0 lands</span>
                      </label>

                      <label style={{ display: 'block', marginBottom: '8px' }}>
                        <input
                          type="checkbox"
                          checked={customMulliganRules.mulligan7Lands}
                          onChange={(e) => setCustomMulliganRules({ ...customMulliganRules, mulligan7Lands: e.target.checked })}
                        />
                        <span style={{ marginLeft: '8px', fontSize: '0.875rem' }}>Mulligan if 7 lands</span>
                      </label>

                      <label style={{ display: 'block', marginBottom: '8px' }}>
                        <input
                          type="checkbox"
                          checked={customMulliganRules.mulliganMinLands}
                          onChange={(e) => setCustomMulliganRules({ ...customMulliganRules, mulliganMinLands: e.target.checked })}
                        />
                        <span style={{ marginLeft: '8px', fontSize: '0.875rem' }}>Mulligan if less than </span>
                        <input
                          type="number"
                          value={customMulliganRules.minLandsThreshold}
                          onChange={(e) => setCustomMulliganRules({ ...customMulliganRules, minLandsThreshold: parseInt(e.target.value) })}
                          min="0"
                          max="7"
                          style={{ width: '50px', marginLeft: '5px', padding: '4px', borderRadius: '4px', border: '1px solid #e5e7eb' }}
                        />
                        <span style={{ marginLeft: '5px', fontSize: '0.875rem' }}>lands</span>
                      </label>

                      <label style={{ display: 'block', marginBottom: '8px' }}>
                        <input
                          type="checkbox"
                          checked={customMulliganRules.mulliganMaxLands}
                          onChange={(e) => setCustomMulliganRules({ ...customMulliganRules, mulliganMaxLands: e.target.checked })}
                        />
                        <span style={{ marginLeft: '8px', fontSize: '0.875rem' }}>Mulligan if more than </span>
                        <input
                          type="number"
                          value={customMulliganRules.maxLandsThreshold}
                          onChange={(e) => setCustomMulliganRules({ ...customMulliganRules, maxLandsThreshold: parseInt(e.target.value) })}
                          min="0"
                          max="7"
                          style={{ width: '50px', marginLeft: '5px', padding: '4px', borderRadius: '4px', border: '1px solid #e5e7eb' }}
                        />
                        <span style={{ marginLeft: '5px', fontSize: '0.875rem' }}>lands</span>
                      </label>

                      <label style={{ display: 'block', marginBottom: '8px' }}>
                        <input
                          type="checkbox"
                          checked={customMulliganRules.mulliganNoPlaysByTurn}
                          onChange={(e) => setCustomMulliganRules({ ...customMulliganRules, mulliganNoPlaysByTurn: e.target.checked })}
                        />
                        <span style={{ marginLeft: '8px', fontSize: '0.875rem' }}>Mulligan if no plays by turn </span>
                        <input
                          type="number"
                          value={customMulliganRules.noPlaysTurnThreshold}
                          onChange={(e) => setCustomMulliganRules({ ...customMulliganRules, noPlaysTurnThreshold: parseInt(e.target.value) })}
                          min="1"
                          max="5"
                          style={{ width: '50px', marginLeft: '5px', padding: '4px', borderRadius: '4px', border: '1px solid #e5e7eb' }}
                        />
                      </label>
                    </div>
                  )}
                </div>
              )}
            </div>

            <button
              onClick={runSimulation}
              disabled={isSimulating}
              style={{
                marginTop: '20px',
                background: isSimulating ? '#9ca3af' : 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                color: 'white',
                padding: '15px 30px',
                borderRadius: '8px',
                border: 'none',
                fontSize: '1.125rem',
                fontWeight: 600,
                cursor: isSimulating ? 'not-allowed' : 'pointer',
                width: '100%'
              }}
            >
              {isSimulating ? 'â³ Simulating...' : 'ðŸŽ² Start Simulation'}
            </button>
          </div>
        </div>
      )}

      {/* Results Section */}
      {simulationResults && chartData && (
        <div id="results-section">
          <div style={{
            background: 'white',
            padding: '20px',
            borderRadius: '12px',
            marginBottom: '20px',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
          }}>
            <h3 style={{ marginTop: 0 }}>ðŸ“Š Simulation Results</h3>
            <p>Iterations: {iterations.toLocaleString()}</p>
            <p>Hands Kept: {simulationResults.handsKept.toLocaleString()}</p>
            {enableMulligans && (
              <p>Mulligan Rate: {iterations > 0 ? ((simulationResults.mulligans / iterations) * 100).toFixed(1) : 0}%</p>
            )}

            <button
              onClick={exportResultsAsPNG}
              style={{
                marginTop: '10px',
                background: '#22c55e',
                color: 'white',
                padding: '10px 20px',
                borderRadius: '6px',
                border: 'none',
                cursor: 'pointer'
              }}
            >
              ðŸ“¸ Export Results as PNG
            </button>
          </div>

          {/* Charts */}
          <div style={{
            background: 'white',
            padding: '20px',
            borderRadius: '12px',
            marginBottom: '20px',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
          }}>
            <h3>Lands per Turn</h3>
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={chartData.landsData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="turn" label={{ value: 'Turn', position: 'insideBottom', offset: -5 }} />
                <YAxis label={{ value: 'Count', angle: -90, position: 'insideLeft' }} />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="Total Lands" stroke="#667eea" strokeWidth={2} />
                <Line type="monotone" dataKey="Untapped Lands" stroke="#22c55e" strokeWidth={2} />
              </LineChart>
            </ResponsiveContainer>
          </div>

          <div style={{
            background: 'white',
            padding: '20px',
            borderRadius: '12px',
            marginBottom: '20px',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
          }}>
            <h3>Available Mana by Color</h3>
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={chartData.manaByColorData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="turn" label={{ value: 'Turn', position: 'insideBottom', offset: -5 }} />
                <YAxis label={{ value: 'Mana', angle: -90, position: 'insideLeft' }} />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="Total Mana" stroke="#7c3aed" strokeWidth={3} />
                <Line type="monotone" dataKey="W" stroke="#fcd34d" strokeWidth={2} />
                <Line type="monotone" dataKey="U" stroke="#60a5fa" strokeWidth={2} />
                <Line type="monotone" dataKey="B" stroke="#6b7280" strokeWidth={2} />
                <Line type="monotone" dataKey="R" stroke="#f87171" strokeWidth={2} />
                <Line type="monotone" dataKey="G" stroke="#4ade80" strokeWidth={2} />
              </LineChart>
            </ResponsiveContainer>
          </div>

          <div style={{
            background: 'white',
            padding: '20px',
            borderRadius: '12px',
            marginBottom: '20px',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
          }}>
            <h3>Cumulative Life Loss</h3>
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={chartData.lifeLossData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="turn" label={{ value: 'Turn', position: 'insideBottom', offset: -5 }} />
                <YAxis label={{ value: 'Life Loss', angle: -90, position: 'insideLeft' }} />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="Life Loss" stroke="#dc2626" strokeWidth={2} />
              </LineChart>
            </ResponsiveContainer>
          </div>

          {selectedKeyCards.size > 0 && (
            <div style={{
              background: 'white',
              padding: '20px',
              borderRadius: '12px',
              marginBottom: '20px',
              boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
            }}>
              <h3>Key Cards Playability (%)</h3>
              <ResponsiveContainer width="100%" height={300}>
                <LineChart data={chartData.keyCardsData}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="turn" label={{ value: 'Turn', position: 'insideBottom', offset: -5 }} />
                  <YAxis label={{ value: 'Playable (%)', angle: -90, position: 'insideLeft' }} />
                  <Tooltip />
                  <Legend />
                  {Array.from(selectedKeyCards).map((cardName, idx) => {
                    const colors = ['#667eea', '#f59e0b', '#22c55e', '#dc2626', '#60a5fa'];
                    const color = colors[idx % colors.length];
                    const burstKey = `${cardName} (+burst)`;
                    const showBurst = simulationResults?.hasBurstCards &&
                      chartData.keyCardsData?.[0]?.[burstKey] !== undefined;
                    return (
                      <React.Fragment key={cardName}>
                        <Line
                          type="monotone"
                          dataKey={cardName}
                          stroke={color}
                          strokeWidth={2}
                        />
                        {showBurst && (
                          <Line
                            type="monotone"
                            dataKey={burstKey}
                            stroke={color}
                            strokeWidth={2}
                            strokeDasharray="6 3"
                            dot={false}
                            name={`${cardName} (+burst)`}
                          />
                        )}
                      </React.Fragment>
                    );
                  })}
                </LineChart>
              </ResponsiveContainer>
            </div>
          )}

          {/* Play Sequences for Selected Turn */}
          {Object.keys(simulationResults.fastestPlaySequences).length > 0 && (
            <div style={{
              background: 'white',
              padding: '20px',
              borderRadius: '12px',
              marginBottom: '20px',
              boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
            }}>
              <h3>âš¡ Play Sequences for Turn {selectedTurnForSequences}</h3>
              <p style={{ fontSize: '0.875rem', color: '#6b7280', marginBottom: '15px' }}>
                Showing example hands that can play key cards on turn {selectedTurnForSequences}
              </p>

              {Object.entries(simulationResults.fastestPlaySequences).map(([cardName, sequencesByTurn]) => {
                const sequencesForTurn = sequencesByTurn[selectedTurnForSequences];
                const burstSequencesForTurn = simulationResults.fastestPlaySequencesBurst?.[cardName]?.[selectedTurnForSequences];

                // Skip if no sequences exist for this turn (base or burst)
                if ((!sequencesForTurn || sequencesForTurn.length === 0) && (!burstSequencesForTurn || burstSequencesForTurn.length === 0)) {
                  return (
                    <div key={cardName} style={{ marginBottom: '25px' }}>
                      <h4 style={{
                        margin: '0 0 10px 0',
                        fontSize: '1.1rem',
                        color: '#667eea',
                        borderBottom: '2px solid #667eea',
                        paddingBottom: '8px'
                      }}>
                        {cardName}
                      </h4>
                      <p style={{
                        fontSize: '0.875rem',
                        color: '#9ca3af',
                        fontStyle: 'italic',
                        padding: '15px',
                        background: '#f9fafb',
                        borderRadius: '8px'
                      }}>
                        No sequences found for turn {selectedTurnForSequences}. This card was not playable on this turn in any simulated games.
                      </p>
                    </div>
                  );
                }

                return (
                  <div key={cardName} style={{ marginBottom: '25px' }}>
                    <h4 style={{
                      margin: '0 0 15px 0',
                      fontSize: '1.1rem',
                      color: '#667eea',
                      borderBottom: '2px solid #667eea',
                      paddingBottom: '8px'
                    }}>
                      {cardName}
                    </h4>

                    {sequencesForTurn && sequencesForTurn.map((data, seqIdx) => (
                      <div key={seqIdx} style={{
                        marginBottom: '15px',
                        padding: '15px',
                        background: '#f9fafb',
                        borderRadius: '8px',
                        border: '2px solid #e5e7eb'
                      }}>
                        <p style={{ margin: '0 0 10px 0', fontSize: '0.875rem', color: '#6b7280' }}>
                          <strong>Example {seqIdx + 1}:</strong> Playable on turn {data.turn} ({data.manaAvailable} mana available)
                        </p>
                        {renderSequenceBody(data, '#667eea')}
                      </div>
                    ))}

                    {/* Burst-only sequences â€” only shown when burst mana makes the difference */}
                    {burstSequencesForTurn && burstSequencesForTurn.length > 0 && (
                      <>
                        <p style={{ fontSize: '0.8rem', fontWeight: 600, color: '#f59e0b', margin: '14px 0 8px 0' }}>
                          âš¡ Burst-only â€” playable only by spending {burstSequencesForTurn[0]?.burstCards?.join(' / ')}
                        </p>
                        {burstSequencesForTurn.map((data, seqIdx) => (
                          <div key={`burst-${seqIdx}`} style={{
                            marginBottom: '15px',
                            padding: '15px',
                            background: '#fffbeb',
                            borderRadius: '8px',
                            border: '2px dashed #f59e0b'
                          }}>
                            <p style={{ margin: '0 0 6px 0', fontSize: '0.875rem', color: '#92400e' }}>
                              <strong>Burst example {seqIdx + 1}:</strong> Turn {data.turn} &mdash;&nbsp;
                              {data.manaAvailable} base + {data.manaWithBurst - data.manaAvailable} burst
                              &nbsp;= {data.manaWithBurst} mana total
                            </p>
                            <p style={{ margin: '0 0 10px 0', fontSize: '0.78rem', color: '#b45309' }}>
                              Burst cards in hand: <strong>{data.burstCards.join(', ')}</strong>
                            </p>
                            {renderSequenceBody(data, '#f59e0b')}
                          </div>
                        ))}
                      </>
                    )}
                  </div>
                );
              })}
            </div>
          )}
        </div>
      )}

      {/* Comparison Mode Results */}

      {/* Footer */}
      <div style={{
        textAlign: 'center',
        padding: '20px',
        color: '#6b7280',
        fontSize: '0.875rem'
      }}>
        <p>All card data Â© Wizards of the Coast</p>
      </div>
    </div>
  );
};

export default MTGMonteCarloAnalyzer;
